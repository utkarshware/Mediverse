{"ast":null,"code":"import _objectSpread from \"C:/Users/51ngh/Documents/GITHUB_Repo/Mediverse/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { _registerComponent, registerVersion, SDK_VERSION } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { A as AbstractUserDataWriter, B as Bytes, D as DocumentReference, p as property, _ as __PRIVATE_setSDKVersion, F as Firestore, a as __PRIVATE_FirebaseAuthCredentialsProvider, b as __PRIVATE_FirebaseAppCheckTokenProvider, c as __PRIVATE_databaseIdFromApp, O as ObjectValue, d as FirestoreError, C, Q as Query, e as __PRIVATE_queryWithAddedFilter, f as __PRIVATE_newUserDataReader, g as __PRIVATE_parseQueryValue, h as FieldFilter, i as __PRIVATE_fieldPathFromArgument, j as CompositeFilter, k as __PRIVATE_queryWithAddedOrderBy, l as __PRIVATE_queryWithLimit, m as __PRIVATE_validatePositiveNumber, n as __PRIVATE_queryWithStartAt, o as __PRIVATE_queryWithEndAt, q as __PRIVATE_queryNormalizedOrderBy, r as __PRIVATE_refValue, s as __PRIVATE_isServerTimestamp, t as Bound, u as __PRIVATE_isCollectionGroupQuery, R as ResourcePath, v as DocumentKey, w as __PRIVATE_valueDescription, x as queryEqual, y as __PRIVATE_cast, z as ensureFirestoreConfigured, E as __PRIVATE_mapToArray, G as __PRIVATE_firestoreClientRunAggregateQuery, H as __PRIVATE_ExpUserDataWriter, I as __PRIVATE_validateJSON, J as __PRIVATE_newSerializer, K as __PRIVATE_createBundleReaderSync, L as __PRIVATE_BundleLoader, M as __PRIVATE_fromDocument, N as __PRIVATE_AutoId, P as __PRIVATE_fromBundledQuery, S as DocumentSet, V as ViewSnapshot, T as __PRIVATE_documentKeySet, U as fail, W as __PRIVATE_parseSetData, X as Precondition, Y as FieldPath, Z as __PRIVATE_parseUpdateVarargs, $ as __PRIVATE_parseUpdateData, a0 as __PRIVATE_DeleteMutation, a1 as __PRIVATE_firestoreClientTransaction, a2 as __PRIVATE_firestoreClientGetDocumentViaSnapshotListener, a3 as __PRIVATE_firestoreClientGetDocumentFromLocalCache, a4 as __PRIVATE_firestoreClientGetDocumentsViaSnapshotListener, a5 as __PRIVATE_firestoreClientGetDocumentsFromLocalCache, a6 as doc, a7 as __PRIVATE_newQueryForPath, a8 as __PRIVATE_firestoreClientListen, a9 as loadBundle, aa as namedQuery, ab as __PRIVATE_firestoreClientAddSnapshotsInSyncListener, ac as __PRIVATE_firestoreClientWrite, ad as __PRIVATE_logWarn, ae as __PRIVATE_fieldPathFromDotSeparatedString, af as IndexSegment, ag as FieldIndex, ah as IndexState, ai as __PRIVATE_firestoreClientSetIndexConfiguration, aj as __PRIVATE_firestoreClientDeleteAllFieldIndexes, ak as __PRIVATE_logDebug, al as __PRIVATE_firestoreClientSetPersistentCacheIndexAutoCreationEnabled, am as __PRIVATE_setTestingHooksSpi, an as OrderBy, ao as __PRIVATE_AggregateImpl, ap as OnlineComponentProvider, aq as __PRIVATE_LruGcMemoryOfflineComponentProvider, ar as __PRIVATE_MemoryOfflineComponentProvider, as as __PRIVATE_IndexedDbOfflineComponentProvider, at as __PRIVATE_MultiTabOfflineComponentProvider } from './common-341bda9b.esm.js';\nexport { A as AbstractUserDataWriter, B as Bytes, au as CACHE_SIZE_UNLIMITED, av as CollectionReference, D as DocumentReference, Y as FieldPath, aw as FieldValue, F as Firestore, d as FirestoreError, ax as GeoPoint, ay as LoadBundleTask, Q as Query, az as Timestamp, aA as VectorValue, N as _AutoId, aB as _ByteString, aC as _DatabaseId, v as _DocumentKey, aD as _EmptyAppCheckTokenProvider, aE as _EmptyAuthCredentialsProvider, aF as _FieldPath, y as _cast, aG as _debugAssert, aH as _internalAggregationQueryToProtoRunAggregationQueryRequest, aI as _internalQueryToProtoQueryTarget, aJ as _isBase64Available, ad as _logWarn, aK as _validateIsNotUsedTogether, aL as arrayRemove, aM as arrayUnion, aN as clearIndexedDbPersistence, aO as collection, aP as collectionGroup, aQ as connectFirestoreEmulator, aR as deleteField, aS as disableNetwork, a6 as doc, aT as documentId, aU as enableIndexedDbPersistence, aV as enableMultiTabIndexedDbPersistence, aW as enableNetwork, z as ensureFirestoreConfigured, aX as getFirestore, aY as increment, aZ as initializeFirestore, a9 as loadBundle, aa as namedQuery, x as queryEqual, a_ as refEqual, a$ as serverTimestamp, b0 as setLogLevel, b1 as terminate, b2 as vector, b3 as waitForPendingWrites } from './common-341bda9b.esm.js';\nimport { getModularInstance, deepEqual } from '@firebase/util';\nimport '@firebase/webchannel-wrapper/bloom-blob';\nimport '@firebase/logger';\nimport '@firebase/webchannel-wrapper/webchannel-blob';\nconst Ut = \"@firebase/firestore\",\n  Ht = \"4.10.0\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction __PRIVATE_isPartialObserver(t) {\n  /**\n  * Returns true if obj is an object and contains at least one of the specified\n  * methods.\n  */\n  return function __PRIVATE_implementsAnyMethods(t, e) {\n    if (\"object\" != typeof t || null === t) return !1;\n    const n = t;\n    for (const t of e) if (t in n && \"function\" == typeof n[t]) return !0;\n    return !1;\n  }\n  /**\n  * @license\n  * Copyright 2020 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */(t, [\"next\", \"error\", \"complete\"]);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n  /**\n   * Create a new AggregateField<T>\n   * @param aggregateType - Specifies the type of aggregation operation to perform.\n   * @param _internalFieldPath - Optionally specifies the field that is aggregated.\n   * @internal\n   */\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"count\";\n    let e = arguments.length > 1 ? arguments[1] : undefined;\n    this._internalFieldPath = e, /** A type string to uniquely identify instances of this class. */\n    this.type = \"AggregateField\", this.aggregateType = t;\n  }\n}\n\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n  /** @hideconstructor */\n  constructor(t, e, n) {\n    this._userDataWriter = e, this._data = n, /** A type string to uniquely identify instances of this class. */\n    this.type = \"AggregateQuerySnapshot\", this.query = t;\n  }\n  /**\n   * Returns the results of the aggregations performed over the underlying\n   * query.\n   *\n   * The keys of the returned object will be the same as those of the\n   * `AggregateSpec` object specified to the aggregation method, and the values\n   * will be the corresponding aggregation result.\n   *\n   * @returns The results of the aggregations performed over the underlying\n   * query.\n   */\n  data() {\n    return this._userDataWriter.convertObjectMap(this._data);\n  }\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the snapshot as a proto value.\n   *\n   * @returns An `Object` containing all fields in the snapshot.\n   */\n  _fieldsProto() {\n    // Return the cloned value to prevent manipulation of the Snapshot's data\n    return new ObjectValue({\n      mapValue: {\n        fields: this._data\n      }\n    }).clone().value.mapValue.fields;\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot$1 {\n  // Note: This class is stripped down version of the DocumentSnapshot in\n  // the legacy SDK. The changes are:\n  // - No support for SnapshotMetadata.\n  // - No support for SnapshotOptions.\n  /** @hideconstructor protected */\n  constructor(t, e, n, r, s) {\n    this._firestore = t, this._userDataWriter = e, this._key = n, this._document = r, this._converter = s;\n  }\n  /** Property of the `DocumentSnapshot` that provides the document's ID. */\n  get id() {\n    return this._key.path.lastSegment();\n  }\n  /**\n   * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n   */\n  get ref() {\n    return new DocumentReference(this._firestore, this._converter, this._key);\n  }\n  /**\n   * Signals whether or not the document at the snapshot's location exists.\n   *\n   * @returns true if the document exists.\n   */\n  exists() {\n    return null !== this._document;\n  }\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  data() {\n    if (this._document) {\n      if (this._converter) {\n        // We only want to use the converter and create a new DocumentSnapshot\n        // if a converter has been provided.\n        const t = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, /* converter= */null);\n        return this._converter.fromFirestore(t);\n      }\n      return this._userDataWriter.convertValue(this._document.data.value);\n    }\n  }\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the document as a proto Value. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  _fieldsProto() {\n    var _this$_document$data$, _this$_document;\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return (_this$_document$data$ = (_this$_document = this._document) === null || _this$_document === void 0 ? void 0 : _this$_document.data.clone().value.mapValue.fields) !== null && _this$_document$data$ !== void 0 ? _this$_document$data$ : void 0;\n  }\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(t) {\n    if (this._document) {\n      const e = this._document.data.field(__PRIVATE_fieldPathFromArgument(\"DocumentSnapshot.get\", t));\n      if (null !== e) return this._userDataWriter.convertValue(e);\n    }\n  }\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * @override\n   * @returns An `Object` containing all fields in the document.\n   */\n  data() {\n    return super.data();\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction __PRIVATE_validateHasExplicitOrderByForLimitToLast(t) {\n  if (\"L\" /* LimitType.Last */ === t.limitType && 0 === t.explicitOrderBy.length) throw new FirestoreError(C.UNIMPLEMENTED, \"limitToLast() queries require specifying at least one orderBy() clause\");\n}\n\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nclass AppliableConstraint {}\n\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nclass QueryConstraint extends AppliableConstraint {}\nfunction query(t, e) {\n  let r = [];\n  for (var _len = arguments.length, n = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    n[_key - 2] = arguments[_key];\n  }\n  e instanceof AppliableConstraint && r.push(e), r = r.concat(n), function __PRIVATE_validateQueryConstraintArray(t) {\n    const e = t.filter(t => t instanceof QueryCompositeFilterConstraint).length,\n      n = t.filter(t => t instanceof QueryFieldFilterConstraint).length;\n    if (e > 1 || e > 0 && n > 0) throw new FirestoreError(C.INVALID_ARGUMENT, \"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.\");\n  }\n  /**\n  * @license\n  * Copyright 2020 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n  /**\n  * Converts custom model object of type T into `DocumentData` by applying the\n  * converter if it exists.\n  *\n  * This function is used when converting user objects to `DocumentData`\n  * because we want to provide the user with a more specific error message if\n  * their `set()` or fails due to invalid data originating from a `toFirestore()`\n  * call.\n  */(r);\n  for (const e of r) t = e._apply(t);\n  return t;\n}\n\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nclass QueryFieldFilterConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  constructor(t, e, n) {\n    super(), this._field = t, this._op = e, this._value = n, /** The type of this query constraint */\n    this.type = \"where\";\n  }\n  static _create(t, e, n) {\n    return new QueryFieldFilterConstraint(t, e, n);\n  }\n  _apply(t) {\n    const e = this._parse(t);\n    return __PRIVATE_validateNewFieldFilter(t._query, e), new Query(t.firestore, t.converter, __PRIVATE_queryWithAddedFilter(t._query, e));\n  }\n  _parse(t) {\n    const e = __PRIVATE_newUserDataReader(t.firestore),\n      n = function __PRIVATE_newQueryFilter(t, e, n, r, s, a, o) {\n        let i;\n        if (s.isKeyField()) {\n          if (\"array-contains\" /* Operator.ARRAY_CONTAINS */ === a || \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ === a) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid Query. You can't perform '\".concat(a, \"' queries on documentId().\"));\n          if (\"in\" /* Operator.IN */ === a || \"not-in\" /* Operator.NOT_IN */ === a) {\n            __PRIVATE_validateDisjunctiveFilterElements(o, a);\n            const e = [];\n            for (const n of o) e.push(__PRIVATE_parseDocumentIdValue(r, t, n));\n            i = {\n              arrayValue: {\n                values: e\n              }\n            };\n          } else i = __PRIVATE_parseDocumentIdValue(r, t, o);\n        } else \"in\" /* Operator.IN */ !== a && \"not-in\" /* Operator.NOT_IN */ !== a && \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */ !== a || __PRIVATE_validateDisjunctiveFilterElements(o, a), i = __PRIVATE_parseQueryValue(n, e, o, /* allowArrays= */\"in\" /* Operator.IN */ === a || \"not-in\" /* Operator.NOT_IN */ === a);\n        const u = FieldFilter.create(s, a, i);\n        return u;\n      }(t._query, \"where\", e, t.firestore._databaseId, this._field, this._op, this._value);\n    return n;\n  }\n}\n\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction where(t, e, n) {\n  const r = e,\n    s = __PRIVATE_fieldPathFromArgument(\"where\", t);\n  return QueryFieldFilterConstraint._create(s, r, n);\n}\n\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\n  /**\n   * @internal\n   */\n  constructor(/** The type of this query constraint */\n  t, e) {\n    super(), this.type = t, this._queryConstraints = e;\n  }\n  static _create(t, e) {\n    return new QueryCompositeFilterConstraint(t, e);\n  }\n  _parse(t) {\n    const e = this._queryConstraints.map(e => e._parse(t)).filter(t => t.getFilters().length > 0);\n    return 1 === e.length ? e[0] : CompositeFilter.create(e, this._getOperator());\n  }\n  _apply(t) {\n    const e = this._parse(t);\n    return 0 === e.getFilters().length ? t : (function __PRIVATE_validateNewFilter(t, e) {\n      let n = t;\n      const r = e.getFlattenedFilters();\n      for (const t of r) __PRIVATE_validateNewFieldFilter(n, t), n = __PRIVATE_queryWithAddedFilter(n, t);\n    }\n    // Checks if any of the provided filter operators are included in the given list of filters and\n    // returns the first one that is, or null if none are.\n    (t._query, e), new Query(t.firestore, t.converter, __PRIVATE_queryWithAddedFilter(t._query, e)));\n  }\n  _getQueryConstraints() {\n    return this._queryConstraints;\n  }\n  _getOperator() {\n    return \"and\" === this.type ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n  }\n}\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction or() {\n  for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    t[_key2] = arguments[_key2];\n  }\n  // Only support QueryFilterConstraints\n  return t.forEach(t => __PRIVATE_validateQueryFilterConstraint(\"or\", t)), QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, t);\n}\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction and() {\n  for (var _len3 = arguments.length, t = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    t[_key3] = arguments[_key3];\n  }\n  // Only support QueryFilterConstraints\n  return t.forEach(t => __PRIVATE_validateQueryFilterConstraint(\"and\", t)), QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, t);\n}\n\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nclass QueryOrderByConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  constructor(t, e) {\n    super(), this._field = t, this._direction = e, /** The type of this query constraint */\n    this.type = \"orderBy\";\n  }\n  static _create(t, e) {\n    return new QueryOrderByConstraint(t, e);\n  }\n  _apply(t) {\n    const e = function __PRIVATE_newQueryOrderBy(t, e, n) {\n      if (null !== t.startAt) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. You must not call startAt() or startAfter() before calling orderBy().\");\n      if (null !== t.endAt) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. You must not call endAt() or endBefore() before calling orderBy().\");\n      const r = new OrderBy(e, n);\n      return r;\n    }\n    /**\n    * Create a `Bound` from a query and a document.\n    *\n    * Note that the `Bound` will always include the key of the document\n    * and so only the provided document will compare equal to the returned\n    * position.\n    *\n    * Will throw if the document does not contain all fields of the order by\n    * of the query or if any of the fields in the order by are an uncommitted\n    * server timestamp.\n    */(t._query, this._field, this._direction);\n    return new Query(t.firestore, t.converter, __PRIVATE_queryWithAddedOrderBy(t._query, e));\n  }\n}\n\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction orderBy(t) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"asc\";\n  const n = e,\n    r = __PRIVATE_fieldPathFromArgument(\"orderBy\", t);\n  return QueryOrderByConstraint._create(r, n);\n}\n\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nclass QueryLimitConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  constructor(/** The type of this query constraint */\n  t, e, n) {\n    super(), this.type = t, this._limit = e, this._limitType = n;\n  }\n  static _create(t, e, n) {\n    return new QueryLimitConstraint(t, e, n);\n  }\n  _apply(t) {\n    return new Query(t.firestore, t.converter, __PRIVATE_queryWithLimit(t._query, this._limit, this._limitType));\n  }\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limit(t) {\n  return __PRIVATE_validatePositiveNumber(\"limit\", t), QueryLimitConstraint._create(\"limit\", t, \"F\" /* LimitType.First */);\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limitToLast(t) {\n  return __PRIVATE_validatePositiveNumber(\"limitToLast\", t), QueryLimitConstraint._create(\"limitToLast\", t, \"L\" /* LimitType.Last */);\n}\n\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nclass QueryStartAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  constructor(/** The type of this query constraint */\n  t, e, n) {\n    super(), this.type = t, this._docOrFields = e, this._inclusive = n;\n  }\n  static _create(t, e, n) {\n    return new QueryStartAtConstraint(t, e, n);\n  }\n  _apply(t) {\n    const e = __PRIVATE_newQueryBoundFromDocOrFields(t, this.type, this._docOrFields, this._inclusive);\n    return new Query(t.firestore, t.converter, __PRIVATE_queryWithStartAt(t._query, e));\n  }\n}\nfunction startAt() {\n  for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    t[_key4] = arguments[_key4];\n  }\n  return QueryStartAtConstraint._create(\"startAt\", t, /*inclusive=*/!0);\n}\nfunction startAfter() {\n  for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    t[_key5] = arguments[_key5];\n  }\n  return QueryStartAtConstraint._create(\"startAfter\", t, /*inclusive=*/!1);\n}\n\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nclass QueryEndAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  constructor(/** The type of this query constraint */\n  t, e, n) {\n    super(), this.type = t, this._docOrFields = e, this._inclusive = n;\n  }\n  static _create(t, e, n) {\n    return new QueryEndAtConstraint(t, e, n);\n  }\n  _apply(t) {\n    const e = __PRIVATE_newQueryBoundFromDocOrFields(t, this.type, this._docOrFields, this._inclusive);\n    return new Query(t.firestore, t.converter, __PRIVATE_queryWithEndAt(t._query, e));\n  }\n}\nfunction endBefore() {\n  for (var _len6 = arguments.length, t = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    t[_key6] = arguments[_key6];\n  }\n  return QueryEndAtConstraint._create(\"endBefore\", t, /*inclusive=*/!1);\n}\nfunction endAt() {\n  for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    t[_key7] = arguments[_key7];\n  }\n  return QueryEndAtConstraint._create(\"endAt\", t, /*inclusive=*/!0);\n}\n\n/** Helper function to create a bound from a document or fields */\nfunction __PRIVATE_newQueryBoundFromDocOrFields(t, e, n, r) {\n  if (n[0] = getModularInstance(n[0]), n[0] instanceof DocumentSnapshot$1) return function __PRIVATE_newQueryBoundFromDocument(t, e, n, r, s) {\n    if (!r) throw new FirestoreError(C.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \".concat(n, \"().\"));\n    const a = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const n of __PRIVATE_queryNormalizedOrderBy(t)) if (n.field.isKeyField()) a.push(__PRIVATE_refValue(e, r.key));else {\n      const t = r.data.field(n.field);\n      if (__PRIVATE_isServerTimestamp(t)) throw new FirestoreError(C.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field \"' + n.field + '\" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');\n      if (null === t) {\n        const t = n.field.canonicalString();\n        throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a document for which the field '\".concat(t, \"' (used as the orderBy) does not exist.\"));\n      }\n      a.push(t);\n    }\n    return new Bound(a, s);\n  }\n  /**\n  * Converts a list of field values to a `Bound` for the given query.\n  */(t._query, t.firestore._databaseId, e, n[0]._document, r);\n  {\n    const s = __PRIVATE_newUserDataReader(t.firestore);\n    return function __PRIVATE_newQueryBoundFromFields(t, e, n, r, s, a) {\n      // Use explicit order by's because it has to match the query the user made\n      const o = t.explicitOrderBy;\n      if (s.length > o.length) throw new FirestoreError(C.INVALID_ARGUMENT, \"Too many arguments provided to \".concat(r, \"(). The number of arguments must be less than or equal to the number of orderBy() clauses\"));\n      const i = [];\n      for (let a = 0; a < s.length; a++) {\n        const u = s[a];\n        if (o[a].field.isKeyField()) {\n          if (\"string\" != typeof u) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \".concat(r, \"(), but got a \").concat(typeof u));\n          if (!__PRIVATE_isCollectionGroupQuery(t) && -1 !== u.indexOf(\"/\")) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying a collection and ordering by documentId(), the value passed to \".concat(r, \"() must be a plain document ID, but '\").concat(u, \"' contains a slash.\"));\n          const n = t.path.child(ResourcePath.fromString(u));\n          if (!DocumentKey.isDocumentKey(n)) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying a collection group and ordering by documentId(), the value passed to \".concat(r, \"() must result in a valid document path, but '\").concat(n, \"' is not because it contains an odd number of segments.\"));\n          const s = new DocumentKey(n);\n          i.push(__PRIVATE_refValue(e, s));\n        } else {\n          const t = __PRIVATE_parseQueryValue(n, r, u);\n          i.push(t);\n        }\n      }\n      return new Bound(i, a);\n    }\n    /**\n    * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n    * appropriate errors if the value is anything other than a `DocumentReference`\n    * or `string`, or if the string is malformed.\n    */(t._query, t.firestore._databaseId, s, e, n, r);\n  }\n}\nfunction __PRIVATE_parseDocumentIdValue(t, e, n) {\n  if (\"string\" == typeof (n = getModularInstance(n))) {\n    if (\"\" === n) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.\");\n    if (!__PRIVATE_isCollectionGroupQuery(e) && -1 !== n.indexOf(\"/\")) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '\".concat(n, \"' contains a '/' character.\"));\n    const r = e.path.child(ResourcePath.fromString(n));\n    if (!DocumentKey.isDocumentKey(r)) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '\".concat(r, \"' is not because it has an odd number of segments (\").concat(r.length, \").\"));\n    return __PRIVATE_refValue(t, new DocumentKey(r));\n  }\n  if (n instanceof DocumentReference) return __PRIVATE_refValue(t, n._key);\n  throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: \".concat(__PRIVATE_valueDescription(n), \".\"));\n}\n\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction __PRIVATE_validateDisjunctiveFilterElements(t, e) {\n  if (!Array.isArray(t) || 0 === t.length) throw new FirestoreError(C.INVALID_ARGUMENT, \"Invalid Query. A non-empty array is required for '\".concat(e.toString(), \"' filters.\"));\n}\n\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction __PRIVATE_validateNewFieldFilter(t, e) {\n  const n = function __PRIVATE_findOpInsideFilters(t, e) {\n    for (const n of t) for (const t of n.getFlattenedFilters()) if (e.indexOf(t.op) >= 0) return t.op;\n    return null;\n  }(t.filters, function __PRIVATE_conflictingOps(t) {\n    switch (t) {\n      case \"!=\" /* Operator.NOT_EQUAL */:\n        return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n      case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n      case \"in\" /* Operator.IN */:\n        return [\"not-in\" /* Operator.NOT_IN */];\n      case \"not-in\" /* Operator.NOT_IN */:\n        return [\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, \"in\" /* Operator.IN */, \"not-in\" /* Operator.NOT_IN */, \"!=\" /* Operator.NOT_EQUAL */];\n      default:\n        return [];\n    }\n  }(e.op));\n  if (null !== n)\n    // Special case when it's a duplicate op to give a slightly clearer error message.\n    throw n === e.op ? new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. You cannot use more than one '\".concat(e.op.toString(), \"' filter.\")) : new FirestoreError(C.INVALID_ARGUMENT, \"Invalid query. You cannot use '\".concat(e.op.toString(), \"' filters with '\").concat(n.toString(), \"' filters.\"));\n}\nfunction __PRIVATE_validateQueryFilterConstraint(t, e) {\n  if (!(e instanceof QueryFieldFilterConstraint || e instanceof QueryCompositeFilterConstraint)) throw new FirestoreError(C.INVALID_ARGUMENT, \"Function \".concat(t, \"() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.\"));\n}\nfunction __PRIVATE_applyFirestoreDataConverter(t, e, n) {\n  let r;\n  // Cast to `any` in order to satisfy the union type constraint on\n  // toFirestore().\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return r = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, r;\n}\nclass __PRIVATE_LiteUserDataWriter extends AbstractUserDataWriter {\n  constructor(t) {\n    super(), this.firestore = t;\n  }\n  convertBytes(t) {\n    return new Bytes(t);\n  }\n  convertReference(t) {\n    const e = this.convertDocumentKey(t, this.firestore._databaseId);\n    return new DocumentReference(this.firestore, /* converter= */null, e);\n  }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to sum across the result set.\n */\nfunction sum(t) {\n  return new AggregateField(\"sum\", __PRIVATE_fieldPathFromArgument(\"sum\", t));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to average across the result set.\n */\nfunction average(t) {\n  return new AggregateField(\"avg\", __PRIVATE_fieldPathFromArgument(\"average\", t));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nfunction count() {\n  return new AggregateField(\"count\");\n}\n\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left - Compare this AggregateField to the `right`.\n * @param right - Compare this AggregateField to the `left`.\n */\nfunction aggregateFieldEqual(t, e) {\n  var _t$_internalFieldPath, _e$_internalFieldPath;\n  return t instanceof AggregateField && e instanceof AggregateField && t.aggregateType === e.aggregateType && ((_t$_internalFieldPath = t._internalFieldPath) === null || _t$_internalFieldPath === void 0 ? void 0 : _t$_internalFieldPath.canonicalString()) === ((_e$_internalFieldPath = e._internalFieldPath) === null || _e$_internalFieldPath === void 0 ? void 0 : _e$_internalFieldPath.canonicalString());\n}\n\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction aggregateQuerySnapshotEqual(t, e) {\n  return queryEqual(t.query, e.query) && deepEqual(t.data(), e.data());\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction getCountFromServer(t) {\n  return getAggregateFromServer(t, {\n    count: count()\n  });\n}\n\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nfunction getAggregateFromServer(t, e) {\n  const n = __PRIVATE_cast(t.firestore, Firestore),\n    r = ensureFirestoreConfigured(n),\n    s = __PRIVATE_mapToArray(e, (t, e) => new __PRIVATE_AggregateImpl(e, t.aggregateType, t._internalFieldPath));\n  // Run the aggregation and convert the results\n  return __PRIVATE_firestoreClientRunAggregateQuery(r, t._query, s).then(e =>\n  /**\n  * Converts the core aggregation result to an `AggregateQuerySnapshot`\n  * that can be returned to the consumer.\n  * @param query\n  * @param aggregateResult - Core aggregation result\n  * @internal\n  */\n  function __PRIVATE_convertToAggregateQuerySnapshot(t, e, n) {\n    const r = new __PRIVATE_ExpUserDataWriter(t),\n      s = new AggregateQuerySnapshot(e, r, n);\n    return s;\n  }\n  /**\n  * @license\n  * Copyright 2023 Google LLC\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */(n, t, e));\n}\nclass __PRIVATE_MemoryLocalCacheImpl {\n  constructor(t) {\n    this.kind = \"memory\", this._onlineComponentProvider = OnlineComponentProvider.provider, this._offlineComponentProvider = t !== null && t !== void 0 && t.garbageCollector ? t.garbageCollector._offlineComponentProvider : {\n      build: () => new __PRIVATE_LruGcMemoryOfflineComponentProvider(void 0)\n    };\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n}\nclass __PRIVATE_PersistentLocalCacheImpl {\n  constructor(t) {\n    let e;\n    this.kind = \"persistent\", t !== null && t !== void 0 && t.tabManager ? (t.tabManager._initialize(t), e = t.tabManager) : (e = persistentSingleTabManager(void 0), e._initialize(t)), this._onlineComponentProvider = e._onlineComponentProvider, this._offlineComponentProvider = e._offlineComponentProvider;\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n}\nclass __PRIVATE_MemoryEagerGarbageCollectorImpl {\n  constructor() {\n    this.kind = \"memoryEager\", this._offlineComponentProvider = __PRIVATE_MemoryOfflineComponentProvider.provider;\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n}\nclass __PRIVATE_MemoryLruGarbageCollectorImpl {\n  constructor(t) {\n    this.kind = \"memoryLru\", this._offlineComponentProvider = {\n      build: () => new __PRIVATE_LruGcMemoryOfflineComponentProvider(t)\n    };\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n}\n\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nfunction memoryEagerGarbageCollector() {\n  return new __PRIVATE_MemoryEagerGarbageCollectorImpl();\n}\n\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nfunction memoryLruGarbageCollector(t) {\n  return new __PRIVATE_MemoryLruGarbageCollectorImpl(t === null || t === void 0 ? void 0 : t.cacheSizeBytes);\n}\n\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nfunction memoryLocalCache(t) {\n  return new __PRIVATE_MemoryLocalCacheImpl(t);\n}\n\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nfunction persistentLocalCache(t) {\n  return new __PRIVATE_PersistentLocalCacheImpl(t);\n}\nclass __PRIVATE_SingleTabManagerImpl {\n  constructor(t) {\n    this.forceOwnership = t, this.kind = \"persistentSingleTab\";\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n  /**\n   * @internal\n   */\n  _initialize(t) {\n    this._onlineComponentProvider = OnlineComponentProvider.provider, this._offlineComponentProvider = {\n      build: e => new __PRIVATE_IndexedDbOfflineComponentProvider(e, t === null || t === void 0 ? void 0 : t.cacheSizeBytes, this.forceOwnership)\n    };\n  }\n}\nclass __PRIVATE_MultiTabManagerImpl {\n  constructor() {\n    this.kind = \"PersistentMultipleTab\";\n  }\n  toJSON() {\n    return {\n      kind: this.kind\n    };\n  }\n  /**\n   * @internal\n   */\n  _initialize(t) {\n    this._onlineComponentProvider = OnlineComponentProvider.provider, this._offlineComponentProvider = {\n      build: e => new __PRIVATE_MultiTabOfflineComponentProvider(e, t === null || t === void 0 ? void 0 : t.cacheSizeBytes)\n    };\n  }\n}\n\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings - Configures the created tab manager.\n */\nfunction persistentSingleTabManager(t) {\n  return new __PRIVATE_SingleTabManagerImpl(t === null || t === void 0 ? void 0 : t.forceOwnership);\n}\n\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nfunction persistentMultipleTabManager() {\n  return new __PRIVATE_MultiTabManagerImpl();\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst zt = \"NOT SUPPORTED\";\n\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nclass SnapshotMetadata {\n  /** @hideconstructor */\n  constructor(t, e) {\n    this.hasPendingWrites = t, this.fromCache = e;\n  }\n  /**\n   * Returns true if this `SnapshotMetadata` is equal to the provided one.\n   *\n   * @param other - The `SnapshotMetadata` to compare against.\n   * @returns true if this `SnapshotMetadata` is equal to the provided one.\n   */\n  isEqual(t) {\n    return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;\n  }\n}\n\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot extends DocumentSnapshot$1 {\n  /** @hideconstructor protected */\n  constructor(t, e, n, r, s, a) {\n    super(t, e, n, r, a), this._firestore = t, this._firestoreImpl = t, this.metadata = s;\n  }\n  /**\n   * Returns whether or not the data exists. True if the document exists.\n   */\n  exists() {\n    return super.exists();\n  }\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document or `undefined` if\n   * the document doesn't exist.\n   */\n  data() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._document) {\n      if (this._converter) {\n        // We only want to use the converter and create a new DocumentSnapshot\n        // if a converter has been provided.\n        const e = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, /* converter= */null);\n        return this._converter.fromFirestore(e, t);\n      }\n      return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps);\n    }\n  }\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * By default, a `serverTimestamp()` that has not yet been set to\n   * its final value will be returned as `null`. You can override this by\n   * passing an options object.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @param options - An options object to configure how the field is retrieved\n   * from the snapshot (for example the desired behavior for server timestamps\n   * that have not yet been set to their final value).\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this._document) {\n      const n = this._document.data.field(__PRIVATE_fieldPathFromArgument(\"DocumentSnapshot.get\", t));\n      if (null !== n) return this._userDataWriter.convertValue(n, e.serverTimestamps);\n    }\n  }\n  /**\n   * Returns a JSON-serializable representation of this `DocumentSnapshot` instance.\n   *\n   * @returns a JSON representation of this object.  Throws a {@link FirestoreError} if this\n   * `DocumentSnapshot` has pending writes.\n   */\n  toJSON() {\n    if (this.metadata.hasPendingWrites) throw new FirestoreError(C.FAILED_PRECONDITION, \"DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().\");\n    const t = this._document,\n      e = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (e.type = DocumentSnapshot._jsonSchemaVersion, e.bundle = \"\", e.bundleSource = \"DocumentSnapshot\", e.bundleName = this._key.toString(), !t || !t.isValidDocument() || !t.isFoundDocument()) return e;\n    this._userDataWriter.convertObjectMap(t.data.value.mapValue.fields, \"previous\");\n    return e.bundle = (this._firestore, this.ref.path, \"NOT SUPPORTED\"), e;\n  }\n}\nfunction documentSnapshotFromJSON(t, e, n) {\n  if (__PRIVATE_validateJSON(e, DocumentSnapshot._jsonSchema)) {\n    if (e.bundle === zt) throw new FirestoreError(C.INVALID_ARGUMENT, \"The provided JSON object was created in a client environment, which is not supported.\");\n    // Parse the bundle data.\n    const r = __PRIVATE_newSerializer(t._databaseId),\n      s = __PRIVATE_createBundleReaderSync(e.bundle, r),\n      a = s.t(),\n      o = new __PRIVATE_BundleLoader(s.getMetadata(), r);\n    for (const t of a) o.o(t);\n    // Ensure that we have the correct number of documents in the bundle.\n    const i = o.documents;\n    if (1 !== i.length) throw new FirestoreError(C.INVALID_ARGUMENT, \"Expected bundle data to contain 1 document, but it contains \".concat(i.length, \" documents.\"));\n    // Build out the internal document data.\n    const u = __PRIVATE_fromDocument(r, i[0].document),\n      c = new DocumentKey(ResourcePath.fromString(e.bundleName));\n    // Return the external facing DocumentSnapshot.\n    return new DocumentSnapshot(t, new __PRIVATE_LiteUserDataWriter(t), c, u, new SnapshotMetadata(/* hasPendingWrites= */!1, /* fromCache= */!1), n || null);\n  }\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nDocumentSnapshot._jsonSchemaVersion = \"firestore/documentSnapshot/1.0\", DocumentSnapshot._jsonSchema = {\n  type: property(\"string\", DocumentSnapshot._jsonSchemaVersion),\n  bundleSource: property(\"string\", \"DocumentSnapshot\"),\n  bundleName: property(\"string\"),\n  bundle: property(\"string\")\n};\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @override\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document.\n   */\n  data() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return super.data(t);\n  }\n}\n\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nclass QuerySnapshot {\n  /** @hideconstructor */\n  constructor(t, e, n, r) {\n    this._firestore = t, this._userDataWriter = e, this._snapshot = r, this.metadata = new SnapshotMetadata(r.hasPendingWrites, r.fromCache), this.query = n;\n  }\n  /** An array of all the documents in the `QuerySnapshot`. */\n  get docs() {\n    const t = [];\n    return this.forEach(e => t.push(e)), t;\n  }\n  /** The number of documents in the `QuerySnapshot`. */\n  get size() {\n    return this._snapshot.docs.size;\n  }\n  /** True if there are no documents in the `QuerySnapshot`. */\n  get empty() {\n    return 0 === this.size;\n  }\n  /**\n   * Enumerates all of the documents in the `QuerySnapshot`.\n   *\n   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n   * each document in the snapshot.\n   * @param thisArg - The `this` binding for the callback.\n   */\n  forEach(t, e) {\n    this._snapshot.docs.forEach(n => {\n      t.call(e, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, n.key, n, new SnapshotMetadata(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));\n    });\n  }\n  /**\n   * Returns an array of the documents changes since the last snapshot. If this\n   * is the first snapshot, all documents will be in the list as 'added'\n   * changes.\n   *\n   * @param options - `SnapshotListenOptions` that control whether metadata-only\n   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n   * snapshot events.\n   */\n  docChanges() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const e = !!t.includeMetadataChanges;\n    if (e && this._snapshot.excludesMetadataChanges) throw new FirestoreError(C.INVALID_ARGUMENT, \"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().\");\n    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = /** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\n    function __PRIVATE_changesFromSnapshot(t, e) {\n      if (t._snapshot.oldDocs.isEmpty()) {\n        let e = 0;\n        return t._snapshot.docChanges.map(n => {\n          const r = new QueryDocumentSnapshot(t._firestore, t._userDataWriter, n.doc.key, n.doc, new SnapshotMetadata(t._snapshot.mutatedKeys.has(n.doc.key), t._snapshot.fromCache), t.query.converter);\n          return n.doc, {\n            type: \"added\",\n            doc: r,\n            oldIndex: -1,\n            newIndex: e++\n          };\n        });\n      }\n      {\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        let n = t._snapshot.oldDocs;\n        return t._snapshot.docChanges.filter(t => e || 3 /* ChangeType.Metadata */ !== t.type).map(e => {\n          const r = new QueryDocumentSnapshot(t._firestore, t._userDataWriter, e.doc.key, e.doc, new SnapshotMetadata(t._snapshot.mutatedKeys.has(e.doc.key), t._snapshot.fromCache), t.query.converter);\n          let s = -1,\n            a = -1;\n          return 0 /* ChangeType.Added */ !== e.type && (s = n.indexOf(e.doc.key), n = n.delete(e.doc.key)), 1 /* ChangeType.Removed */ !== e.type && (n = n.add(e.doc), a = n.indexOf(e.doc.key)), {\n            type: __PRIVATE_resultChangeType(e.type),\n            doc: r,\n            oldIndex: s,\n            newIndex: a\n          };\n        });\n      }\n    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;\n  }\n  /**\n   * Returns a JSON-serializable representation of this `QuerySnapshot` instance.\n   *\n   * @returns a JSON representation of this object. Throws a {@link FirestoreError} if this\n   * `QuerySnapshot` has pending writes.\n   */\n  toJSON() {\n    if (this.metadata.hasPendingWrites) throw new FirestoreError(C.FAILED_PRECONDITION, \"QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().\");\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const t = {};\n    t.type = QuerySnapshot._jsonSchemaVersion, t.bundleSource = \"QuerySnapshot\", t.bundleName = __PRIVATE_AutoId.newId(), this._firestore._databaseId.database, this._firestore._databaseId.projectId;\n    const e = [],\n      n = [],\n      r = [];\n    return this.docs.forEach(t => {\n      null !== t._document && (e.push(t._document), n.push(this._userDataWriter.convertObjectMap(t._document.data.value.mapValue.fields, \"previous\")), r.push(t.ref.path));\n    }), t.bundle = (this._firestore, this.query._query, t.bundleName, \"NOT SUPPORTED\"), t;\n  }\n}\nfunction querySnapshotFromJSON(t, e, n) {\n  if (__PRIVATE_validateJSON(e, QuerySnapshot._jsonSchema)) {\n    if (e.bundle === zt) throw new FirestoreError(C.INVALID_ARGUMENT, \"The provided JSON object was created in a client environment, which is not supported.\");\n    // Parse the bundle data.\n    const r = __PRIVATE_newSerializer(t._databaseId),\n      s = __PRIVATE_createBundleReaderSync(e.bundle, r),\n      a = s.t(),\n      o = new __PRIVATE_BundleLoader(s.getMetadata(), r);\n    for (const t of a) o.o(t);\n    if (1 !== o.queries.length) throw new FirestoreError(C.INVALID_ARGUMENT, \"Snapshot data expected 1 query but found \".concat(o.queries.length, \" queries.\"));\n    // Create an internal Query object from the named query in the bundle.\n    const i = __PRIVATE_fromBundledQuery(o.queries[0].bundledQuery),\n      u = o.documents;\n    // Construct the arrays of document data for the query.\n    let c = new DocumentSet();\n    u.map(t => {\n      const e = __PRIVATE_fromDocument(r, t.document);\n      c = c.add(e);\n    });\n    // Create a view snapshot of the query and documents.\n    const l = ViewSnapshot.fromInitialDocuments(i, c, __PRIVATE_documentKeySet() /* Zero mutated keys signifies no pending writes. */, /* fromCache= */!1, /* hasCachedResults= */!1),\n      h = new Query(t, n || null, i);\n    // Create an external Query object, required to construct the QuerySnapshot.\n    // Return a new QuerySnapshot with all of the collected data.\n    return new QuerySnapshot(t, new __PRIVATE_LiteUserDataWriter(t), h, l);\n  }\n}\nfunction __PRIVATE_resultChangeType(t) {\n  switch (t) {\n    case 0 /* ChangeType.Added */:\n      return \"added\";\n    case 2 /* ChangeType.Modified */:\n    case 3 /* ChangeType.Metadata */:\n      return \"modified\";\n    case 1 /* ChangeType.Removed */:\n      return \"removed\";\n    default:\n      return fail(61501, {\n        type: t\n      });\n  }\n}\n\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction snapshotEqual(t, e) {\n  return t instanceof DocumentSnapshot && e instanceof DocumentSnapshot ? t._firestore === e._firestore && t._key.isEqual(e._key) && (null === t._document ? null === e._document : t._document.isEqual(e._document)) && t._converter === e._converter : t instanceof QuerySnapshot && e instanceof QuerySnapshot && t._firestore === e._firestore && queryEqual(t.query, e.query) && t.metadata.isEqual(e.metadata) && t._snapshot.isEqual(e._snapshot);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nQuerySnapshot._jsonSchemaVersion = \"firestore/querySnapshot/1.0\", QuerySnapshot._jsonSchema = {\n  type: property(\"string\", QuerySnapshot._jsonSchemaVersion),\n  bundleSource: property(\"string\", \"QuerySnapshot\"),\n  bundleName: property(\"string\"),\n  bundle: property(\"string\")\n};\nconst Yt = {\n  maxAttempts: 5\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nclass WriteBatch {\n  /** @hideconstructor */\n  constructor(t, e) {\n    this._firestore = t, this._commitHandler = e, this._mutations = [], this._committed = !1, this._dataReader = __PRIVATE_newUserDataReader(t);\n  }\n  set(t, e, n) {\n    this._verifyNotCommitted();\n    const r = __PRIVATE_validateReference(t, this._firestore),\n      s = __PRIVATE_applyFirestoreDataConverter(r.converter, e, n),\n      a = __PRIVATE_parseSetData(this._dataReader, \"WriteBatch.set\", r._key, s, null !== r.converter, n);\n    return this._mutations.push(a.toMutation(r._key, Precondition.none())), this;\n  }\n  update(t, e, n) {\n    this._verifyNotCommitted();\n    const s = __PRIVATE_validateReference(t, this._firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    let a;\n    for (var _len8 = arguments.length, r = new Array(_len8 > 3 ? _len8 - 3 : 0), _key8 = 3; _key8 < _len8; _key8++) {\n      r[_key8 - 3] = arguments[_key8];\n    }\n    return a = \"string\" == typeof (e = getModularInstance(e)) || e instanceof FieldPath ? __PRIVATE_parseUpdateVarargs(this._dataReader, \"WriteBatch.update\", s._key, e, n, r) : __PRIVATE_parseUpdateData(this._dataReader, \"WriteBatch.update\", s._key, e), this._mutations.push(a.toMutation(s._key, Precondition.exists(!0))), this;\n  }\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  delete(t) {\n    this._verifyNotCommitted();\n    const e = __PRIVATE_validateReference(t, this._firestore);\n    return this._mutations = this._mutations.concat(new __PRIVATE_DeleteMutation(e._key, Precondition.none())), this;\n  }\n  /**\n   * Commits all of the writes in this write batch as a single atomic unit.\n   *\n   * The result of these writes will only be reflected in document reads that\n   * occur after the returned promise resolves. If the client is offline, the\n   * write fails. If you would like to see local modifications or buffer writes\n   * until the client is online, use the full Firestore SDK.\n   *\n   * @returns A `Promise` resolved once all of the writes in the batch have been\n   * successfully written to the backend as an atomic unit (note that it won't\n   * resolve while you're offline).\n   */\n  commit() {\n    return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();\n  }\n  _verifyNotCommitted() {\n    if (this._committed) throw new FirestoreError(C.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() has been called.\");\n  }\n}\nfunction __PRIVATE_validateReference(t, e) {\n  if ((t = getModularInstance(t)).firestore !== e) throw new FirestoreError(C.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n  return t;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction$1 {\n  /** @hideconstructor */\n  constructor(t, e) {\n    this._firestore = t, this._transaction = e, this._dataReader = __PRIVATE_newUserDataReader(t);\n  }\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get(t) {\n    const e = __PRIVATE_validateReference(t, this._firestore),\n      n = new __PRIVATE_LiteUserDataWriter(this._firestore);\n    return this._transaction.lookup([e._key]).then(t => {\n      if (!t || 1 !== t.length) return fail(24041);\n      const r = t[0];\n      if (r.isFoundDocument()) return new DocumentSnapshot$1(this._firestore, n, r.key, r, e.converter);\n      if (r.isNoDocument()) return new DocumentSnapshot$1(this._firestore, n, e._key, null, e.converter);\n      throw fail(18433, {\n        doc: r\n      });\n    });\n  }\n  set(t, e, n) {\n    const r = __PRIVATE_validateReference(t, this._firestore),\n      s = __PRIVATE_applyFirestoreDataConverter(r.converter, e, n),\n      a = __PRIVATE_parseSetData(this._dataReader, \"Transaction.set\", r._key, s, null !== r.converter, n);\n    return this._transaction.set(r._key, a), this;\n  }\n  update(t, e, n) {\n    const s = __PRIVATE_validateReference(t, this._firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    let a;\n    for (var _len9 = arguments.length, r = new Array(_len9 > 3 ? _len9 - 3 : 0), _key9 = 3; _key9 < _len9; _key9++) {\n      r[_key9 - 3] = arguments[_key9];\n    }\n    return a = \"string\" == typeof (e = getModularInstance(e)) || e instanceof FieldPath ? __PRIVATE_parseUpdateVarargs(this._dataReader, \"Transaction.update\", s._key, e, n, r) : __PRIVATE_parseUpdateData(this._dataReader, \"Transaction.update\", s._key, e), this._transaction.update(s._key, a), this;\n  }\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  delete(t) {\n    const e = __PRIVATE_validateReference(t, this._firestore);\n    return this._transaction.delete(e._key), this;\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction extends Transaction$1 {\n  // This class implements the same logic as the Transaction API in the Lite SDK\n  // but is subclassed in order to return its own DocumentSnapshot types.\n  /** @hideconstructor */\n  constructor(t, e) {\n    super(t, e), this._firestore = t;\n  }\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get(t) {\n    const e = __PRIVATE_validateReference(t, this._firestore),\n      n = new __PRIVATE_ExpUserDataWriter(this._firestore);\n    return super.get(t).then(t => new DocumentSnapshot(this._firestore, n, e._key, t._document, new SnapshotMetadata(/* hasPendingWrites= */!1, /* fromCache= */!1), e.converter));\n  }\n}\n\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction runTransaction(t, e, n) {\n  t = __PRIVATE_cast(t, Firestore);\n  const r = _objectSpread(_objectSpread({}, Yt), n);\n  !function __PRIVATE_validateTransactionOptions(t) {\n    if (t.maxAttempts < 1) throw new FirestoreError(C.INVALID_ARGUMENT, \"Max attempts must be at least 1\");\n  }(r);\n  const s = ensureFirestoreConfigured(t);\n  return __PRIVATE_firestoreClientTransaction(s, n => e(new Transaction(t, n)), r);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDoc(t) {\n  t = __PRIVATE_cast(t, DocumentReference);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e);\n  return __PRIVATE_firestoreClientGetDocumentViaSnapshotListener(n, t._key).then(n => __PRIVATE_convertToDocSnapshot(e, t, n));\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromCache(t) {\n  t = __PRIVATE_cast(t, DocumentReference);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e),\n    r = new __PRIVATE_ExpUserDataWriter(e);\n  return __PRIVATE_firestoreClientGetDocumentFromLocalCache(n, t._key).then(n => new DocumentSnapshot(e, r, t._key, n, new SnapshotMetadata(null !== n && n.hasLocalMutations, /* fromCache= */!0), t.converter));\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromServer(t) {\n  t = __PRIVATE_cast(t, DocumentReference);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e);\n  return __PRIVATE_firestoreClientGetDocumentViaSnapshotListener(n, t._key, {\n    source: \"server\"\n  }).then(n => __PRIVATE_convertToDocSnapshot(e, t, n));\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocs(t) {\n  t = __PRIVATE_cast(t, Query);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e),\n    r = new __PRIVATE_ExpUserDataWriter(e);\n  return __PRIVATE_validateHasExplicitOrderByForLimitToLast(t._query), __PRIVATE_firestoreClientGetDocumentsViaSnapshotListener(n, t._query).then(n => new QuerySnapshot(e, r, t, n));\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromCache(t) {\n  t = __PRIVATE_cast(t, Query);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e),\n    r = new __PRIVATE_ExpUserDataWriter(e);\n  return __PRIVATE_firestoreClientGetDocumentsFromLocalCache(n, t._query).then(n => new QuerySnapshot(e, r, t, n));\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromServer(t) {\n  t = __PRIVATE_cast(t, Query);\n  const e = __PRIVATE_cast(t.firestore, Firestore),\n    n = ensureFirestoreConfigured(e),\n    r = new __PRIVATE_ExpUserDataWriter(e);\n  return __PRIVATE_firestoreClientGetDocumentsViaSnapshotListener(n, t._query, {\n    source: \"server\"\n  }).then(n => new QuerySnapshot(e, r, t, n));\n}\nfunction setDoc(t, e, n) {\n  t = __PRIVATE_cast(t, DocumentReference);\n  const r = __PRIVATE_cast(t.firestore, Firestore),\n    s = __PRIVATE_applyFirestoreDataConverter(t.converter, e, n),\n    o = __PRIVATE_newUserDataReader(r);\n  return executeWrite(r, [__PRIVATE_parseSetData(o, \"setDoc\", t._key, s, null !== t.converter, n).toMutation(t._key, Precondition.none())]);\n}\nfunction updateDoc(t, e, n) {\n  t = __PRIVATE_cast(t, DocumentReference);\n  const s = __PRIVATE_cast(t.firestore, Firestore),\n    o = __PRIVATE_newUserDataReader(s);\n  let i;\n  for (var _len0 = arguments.length, r = new Array(_len0 > 3 ? _len0 - 3 : 0), _key0 = 3; _key0 < _len0; _key0++) {\n    r[_key0 - 3] = arguments[_key0];\n  }\n  i = \"string\" == typeof (\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  e = getModularInstance(e)) || e instanceof FieldPath ? __PRIVATE_parseUpdateVarargs(o, \"updateDoc\", t._key, e, n, r) : __PRIVATE_parseUpdateData(o, \"updateDoc\", t._key, e);\n  return executeWrite(s, [i.toMutation(t._key, Precondition.exists(!0))]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nfunction deleteDoc(t) {\n  return executeWrite(__PRIVATE_cast(t.firestore, Firestore), [new __PRIVATE_DeleteMutation(t._key, Precondition.none())]);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nfunction addDoc(t, e) {\n  const n = __PRIVATE_cast(t.firestore, Firestore),\n    r = doc(t),\n    s = __PRIVATE_applyFirestoreDataConverter(t.converter, e),\n    o = __PRIVATE_newUserDataReader(t.firestore);\n  return executeWrite(n, [__PRIVATE_parseSetData(o, \"addDoc\", r._key, s, null !== t.converter, {}).toMutation(r._key, Precondition.exists(!1))]).then(() => r);\n}\nfunction onSnapshot(t) {\n  for (var _len1 = arguments.length, e = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {\n    e[_key1 - 1] = arguments[_key1];\n  }\n  // onSnapshot for Query or Document.\n  t = getModularInstance(t);\n  let n = {\n      includeMetadataChanges: !1,\n      source: \"default\"\n    },\n    r = 0;\n  \"object\" != typeof e[r] || __PRIVATE_isPartialObserver(e[r]) || (n = e[r++]);\n  const s = {\n    includeMetadataChanges: n.includeMetadataChanges,\n    source: n.source\n  };\n  if (__PRIVATE_isPartialObserver(e[r])) {\n    var _t$next, _t$error, _t$complete;\n    const t = e[r];\n    e[r] = (_t$next = t.next) === null || _t$next === void 0 ? void 0 : _t$next.bind(t), e[r + 1] = (_t$error = t.error) === null || _t$error === void 0 ? void 0 : _t$error.bind(t), e[r + 2] = (_t$complete = t.complete) === null || _t$complete === void 0 ? void 0 : _t$complete.bind(t);\n  }\n  let o, i, u;\n  if (t instanceof DocumentReference) i = __PRIVATE_cast(t.firestore, Firestore), u = __PRIVATE_newQueryForPath(t._key.path), o = {\n    next: n => {\n      e[r] && e[r](__PRIVATE_convertToDocSnapshot(i, t, n));\n    },\n    error: e[r + 1],\n    complete: e[r + 2]\n  };else {\n    const n = __PRIVATE_cast(t, Query);\n    i = __PRIVATE_cast(n.firestore, Firestore), u = n._query;\n    const s = new __PRIVATE_ExpUserDataWriter(i);\n    o = {\n      next: t => {\n        e[r] && e[r](new QuerySnapshot(i, s, n, t));\n      },\n      error: e[r + 1],\n      complete: e[r + 2]\n    }, __PRIVATE_validateHasExplicitOrderByForLimitToLast(t._query);\n  }\n  const c = ensureFirestoreConfigured(i);\n  return __PRIVATE_firestoreClientListen(c, u, s, o);\n}\nfunction onSnapshotResume(t, e) {\n  const r = getModularInstance(t),\n    s =\n    /**\n    * Ensures the data required to construct an {@link onSnapshot} listener exist in a `snapshotJson`\n    * object that originates from {@link DocumentSnapshot.toJSON} or {@link Querysnapshot.toJSON}. The\n    * data is normalized into a typed object.\n    *\n    * @param snapshotJson - The JSON object that the app provided to {@link onSnapshot}.\n    * @returns A normalized object that contains all of the required bundle JSON fields. If\n    * {@link snapshotJson} doesn't contain the required fields, or if the fields exist as empty\n    * strings, then the {@link snapshotJson.error} field will be a non empty string.\n    *\n    * @internal\n    */\n    function __PRIVATE_normalizeSnapshotJsonFields(t) {\n      const e = {\n          bundle: \"\",\n          bundleName: \"\",\n          bundleSource: \"\"\n        },\n        n = [\"bundle\", \"bundleName\", \"bundleSource\"];\n      for (const r of n) {\n        if (!(r in t)) {\n          e.error = \"snapshotJson missing required field: \".concat(r);\n          break;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const n = t[r];\n        if (\"string\" != typeof n) {\n          e.error = \"snapshotJson field '\".concat(r, \"' must be a string.\");\n          break;\n        }\n        if (0 === n.length) {\n          e.error = \"snapshotJson field '\".concat(r, \"' cannot be an empty string.\");\n          break;\n        }\n        \"bundle\" === r ? e.bundle = n : \"bundleName\" === r ? e.bundleName = n : \"bundleSource\" === r && (e.bundleSource = n);\n      }\n      return e;\n    }\n    /**\n    * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n    * {@link DocumentReference} for the document in the bundle.\n    *\n    * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n    * @param json - The JSON bundle to load, produced by {@link DocumentSnapshot.toJSON}.\n    * @param options - Options controlling the listen behavior.\n    * @param observer - A single object containing `next` and `error` callbacks.\n    * @param converter - An optional object that converts objects from Firestore before the onNext\n    * listener is invoked.\n    * @returns An unsubscribe function that can be called to cancel the snapshot\n    * listener.\n    *\n    * @internal\n    */(e);\n  if (s.error) throw new FirestoreError(C.INVALID_ARGUMENT, s.error);\n  let a,\n    o = 0;\n  for (var _len10 = arguments.length, n = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n    n[_key10 - 2] = arguments[_key10];\n  }\n  if (\"object\" != typeof n[o] || __PRIVATE_isPartialObserver(n[o]) || (a = n[o++]), \"QuerySnapshot\" === s.bundleSource) {\n    let t = null;\n    if (\"object\" == typeof n[o] && __PRIVATE_isPartialObserver(n[o])) {\n      const e = n[o++];\n      t = {\n        next: e.next,\n        error: e.error,\n        complete: e.complete\n      };\n    } else t = {\n      next: n[o++],\n      error: n[o++],\n      complete: n[o++]\n    };\n    /**\n    * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n    * {@link Query} that represents the Query in the bundle.\n    *\n    * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n    * @param json - The JSON bundle to load, produced by {@link QuerySnapshot.toJSON}.\n    * @param options - Options controlling the listen behavior.\n    * @param observer - A single object containing `next` and `error` callbacks.\n    * @param converter - An optional object that converts objects from Firestore before the onNext\n    * listener is invoked.\n    * @returns An unsubscribe function that can be called to cancel the snapshot\n    * listener.\n    *\n    * @internal\n    */\n    return function __PRIVATE_onSnapshotQuerySnapshotBundle(t, e, n, r, s) {\n      let a,\n        o = !1;\n      const i = loadBundle(t, e.bundle);\n      return i.then(() => namedQuery(t, e.bundleName)).then(t => {\n        if (t && !o) {\n          s && t.withConverter(s), a = onSnapshot(t, n || {}, r);\n        }\n      }).catch(t => (r.error && r.error(t), () => {})), () => {\n        o || (o = !0, a && a());\n      };\n    }\n    /**\n    * @license\n    * Copyright 2020 Google LLC\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n    * Creates a write batch, used for performing multiple writes as a single\n    * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n    * is 500.\n    *\n    * Unlike transactions, write batches are persisted offline and therefore are\n    * preferable when you don't need to condition your writes on read data.\n    *\n    * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n    * writes.\n    */(r, s, a, t, n[o]);\n  }\n  if (\"DocumentSnapshot\" === s.bundleSource) {\n    let t = null;\n    if (\"object\" == typeof n[o] && __PRIVATE_isPartialObserver(n[o])) {\n      const e = n[o++];\n      t = {\n        next: e.next,\n        error: e.error,\n        complete: e.complete\n      };\n    } else t = {\n      next: n[o++],\n      error: n[o++],\n      complete: n[o++]\n    };\n    return function __PRIVATE_onSnapshotDocumentSnapshotBundle(t, e, n, r, s) {\n      let a,\n        o = !1;\n      const i = loadBundle(t, e.bundle);\n      return i.then(() => {\n        if (!o) {\n          const o = new DocumentReference(t, s || null, DocumentKey.fromPath(e.bundleName));\n          a = onSnapshot(o, n || {}, r);\n        }\n      }).catch(t => (r.error && r.error(t), () => {})), () => {\n        o || (o = !0, a && a());\n      };\n    }(r, s, a, t, n[o]);\n  }\n  throw new FirestoreError(C.INVALID_ARGUMENT, \"unsupported bundle source: \".concat(s.bundleSource));\n}\nfunction onSnapshotsInSync(t, e) {\n  t = __PRIVATE_cast(t, Firestore);\n  const n = ensureFirestoreConfigured(t),\n    r = __PRIVATE_isPartialObserver(e) ? e : {\n      next: e\n    };\n  return __PRIVATE_firestoreClientAddSnapshotsInSyncListener(n, r);\n}\n\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nfunction executeWrite(t, e) {\n  const n = ensureFirestoreConfigured(t);\n  return __PRIVATE_firestoreClientWrite(n, e);\n}\n\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction __PRIVATE_convertToDocSnapshot(t, e, n) {\n  const r = n.docs.get(e._key),\n    s = new __PRIVATE_ExpUserDataWriter(t);\n  return new DocumentSnapshot(t, s, e._key, r, new SnapshotMetadata(n.hasPendingWrites, n.fromCache), e.converter);\n}\nfunction writeBatch(t) {\n  return t = __PRIVATE_cast(t, Firestore), ensureFirestoreConfigured(t), new WriteBatch(t, e => executeWrite(t, e));\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction setIndexConfiguration(t, e) {\n  t = __PRIVATE_cast(t, Firestore);\n  const n = ensureFirestoreConfigured(t);\n  if (!n._uninitializedComponentsProvider || \"memory\" === n._uninitializedComponentsProvider._offline.kind)\n    // PORTING NOTE: We don't return an error if the user has not enabled\n    // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n    return __PRIVATE_logWarn(\"Cannot enable indexes when persistence is disabled\"), Promise.resolve();\n  const r = function __PRIVATE_parseIndexes(t) {\n    const e = \"string\" == typeof t ? function __PRIVATE_tryParseJson(t) {\n        try {\n          return JSON.parse(t);\n        } catch (t) {\n          throw new FirestoreError(C.INVALID_ARGUMENT, \"Failed to parse JSON: \" + (t === null || t === void 0 ? void 0 : t.message));\n        }\n      }(t) : t,\n      n = [];\n    if (Array.isArray(e.indexes)) for (const t of e.indexes) {\n      const e = __PRIVATE_tryGetString(t, \"collectionGroup\"),\n        r = [];\n      if (Array.isArray(t.fields)) for (const e of t.fields) {\n        const t = __PRIVATE_tryGetString(e, \"fieldPath\"),\n          n = __PRIVATE_fieldPathFromDotSeparatedString(\"setIndexConfiguration\", t);\n        \"CONTAINS\" === e.arrayConfig ? r.push(new IndexSegment(n, 2 /* IndexKind.CONTAINS */)) : \"ASCENDING\" === e.order ? r.push(new IndexSegment(n, 0 /* IndexKind.ASCENDING */)) : \"DESCENDING\" === e.order && r.push(new IndexSegment(n, 1 /* IndexKind.DESCENDING */));\n      }\n      n.push(new FieldIndex(FieldIndex.UNKNOWN_ID, e, r, IndexState.empty()));\n    }\n    return n;\n  }(e);\n  return __PRIVATE_firestoreClientSetIndexConfiguration(n, r);\n}\nfunction __PRIVATE_tryGetString(t, e) {\n  if (\"string\" != typeof t[e]) throw new FirestoreError(C.INVALID_ARGUMENT, \"Missing string value for: \" + e);\n  return t[e];\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nclass PersistentCacheIndexManager {\n  /** @hideconstructor */\n  constructor(t) {\n    this._firestore = t, /** A type string to uniquely identify instances of this class. */\n    this.type = \"PersistentCacheIndexManager\";\n  }\n}\n\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @returns The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nfunction getPersistentCacheIndexManager(t) {\n  var _n$_uninitializedComp;\n  t = __PRIVATE_cast(t, Firestore);\n  const e = Kt.get(t);\n  if (e) return e;\n  const n = ensureFirestoreConfigured(t);\n  if (\"persistent\" !== ((_n$_uninitializedComp = n._uninitializedComponentsProvider) === null || _n$_uninitializedComp === void 0 ? void 0 : _n$_uninitializedComp._offline.kind)) return null;\n  const r = new PersistentCacheIndexManager(t);\n  return Kt.set(t, r), r;\n}\n\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nfunction enablePersistentCacheIndexAutoCreation(t) {\n  __PRIVATE_setPersistentCacheIndexAutoCreationEnabled(t, !0);\n}\n\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nfunction disablePersistentCacheIndexAutoCreation(t) {\n  __PRIVATE_setPersistentCacheIndexAutoCreationEnabled(t, !1);\n}\n\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nfunction deleteAllPersistentCacheIndexes(t) {\n  const e = ensureFirestoreConfigured(t._firestore);\n  __PRIVATE_firestoreClientDeleteAllFieldIndexes(e).then(t => __PRIVATE_logDebug(\"deleting all persistent cache indexes succeeded\")).catch(t => __PRIVATE_logWarn(\"deleting all persistent cache indexes failed\", t));\n}\nfunction __PRIVATE_setPersistentCacheIndexAutoCreationEnabled(t, e) {\n  const n = ensureFirestoreConfigured(t._firestore);\n  __PRIVATE_firestoreClientSetPersistentCacheIndexAutoCreationEnabled(n, e).then(t => __PRIVATE_logDebug(\"setting persistent cache index auto creation isEnabled=\".concat(e, \" succeeded\"))).catch(t => __PRIVATE_logWarn(\"setting persistent cache index auto creation isEnabled=\".concat(e, \" failed\"), t));\n}\n\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst Kt = new WeakMap();\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nclass TestingHooks {\n  constructor() {\n    throw new Error(\"instances of this class should not be created\");\n  }\n  /**\n   * Registers a callback to be notified when an existence filter mismatch\n   * occurs in the Watch listen stream.\n   *\n   * The relative order in which callbacks are notified is unspecified; do not\n   * rely on any particular ordering. If a given callback is registered multiple\n   * times then it will be notified multiple times, once per registration.\n   *\n   * @param callback - the callback to invoke upon existence filter mismatch.\n   *\n   * @returns a function that, when called, unregisters the given callback; only\n   * the first invocation of the returned function does anything; all subsequent\n   * invocations do nothing.\n   */\n  static onExistenceFilterMismatch(t) {\n    return __PRIVATE_TestingHooksSpiImpl.instance.onExistenceFilterMismatch(t);\n  }\n}\n\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass __PRIVATE_TestingHooksSpiImpl {\n  constructor() {\n    this.i = new Map();\n  }\n  static get instance() {\n    return Xt || (Xt = new __PRIVATE_TestingHooksSpiImpl(), __PRIVATE_setTestingHooksSpi(Xt)), Xt;\n  }\n  u(t) {\n    this.i.forEach(e => e(t));\n  }\n  onExistenceFilterMismatch(t) {\n    const e = Symbol(),\n      n = this.i;\n    return n.set(e, t), () => n.delete(e);\n  }\n}\nlet Xt = null;\n\n/**\n * Cloud Firestore\n *\n * @packageDocumentation\n */\n!function __PRIVATE_registerFirestore(u) {\n  let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n  __PRIVATE_setSDKVersion(SDK_VERSION), _registerComponent(new Component(\"firestore\", (t, _ref) => {\n    let {\n      instanceIdentifier: e,\n      options: n\n    } = _ref;\n    const r = t.getProvider(\"app\").getImmediate(),\n      s = new Firestore(new __PRIVATE_FirebaseAuthCredentialsProvider(t.getProvider(\"auth-internal\")), new __PRIVATE_FirebaseAppCheckTokenProvider(r, t.getProvider(\"app-check-internal\")), __PRIVATE_databaseIdFromApp(r, e), r);\n    return n = _objectSpread({\n      useFetchStreams: l\n    }, n), s._setSettings(n), s;\n  }, \"PUBLIC\").setMultipleInstances(!0)), registerVersion(Ut, Ht, u),\n  // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation\n  registerVersion(Ut, Ht, \"esm2020\");\n}();\nexport { AggregateField, AggregateQuerySnapshot, DocumentSnapshot, PersistentCacheIndexManager, QueryCompositeFilterConstraint, QueryConstraint, QueryDocumentSnapshot, QueryEndAtConstraint, QueryFieldFilterConstraint, QueryLimitConstraint, QueryOrderByConstraint, QuerySnapshot, QueryStartAtConstraint, SnapshotMetadata, Transaction, WriteBatch, TestingHooks as _TestingHooks, addDoc, aggregateFieldEqual, aggregateQuerySnapshotEqual, and, average, count, deleteAllPersistentCacheIndexes, deleteDoc, disablePersistentCacheIndexAutoCreation, documentSnapshotFromJSON, enablePersistentCacheIndexAutoCreation, endAt, endBefore, executeWrite, getAggregateFromServer, getCountFromServer, getDoc, getDocFromCache, getDocFromServer, getDocs, getDocsFromCache, getDocsFromServer, getPersistentCacheIndexManager, limit, limitToLast, memoryEagerGarbageCollector, memoryLocalCache, memoryLruGarbageCollector, onSnapshot, onSnapshotResume, onSnapshotsInSync, or, orderBy, persistentLocalCache, persistentMultipleTabManager, persistentSingleTabManager, query, querySnapshotFromJSON, runTransaction, setDoc, setIndexConfiguration, snapshotEqual, startAfter, startAt, sum, updateDoc, where, writeBatch };","map":{"version":3,"names":["__PRIVATE_isPartialObserver","t","__PRIVATE_implementsAnyMethods","e","n","AggregateField","constructor","arguments","length","undefined","_internalFieldPath","type","aggregateType","AggregateQuerySnapshot","_userDataWriter","_data","query","data","convertObjectMap","_fieldsProto","ObjectValue","mapValue","fields","clone","value","DocumentSnapshot$1","r","s","_firestore","_key","_document","_converter","id","path","lastSegment","ref","DocumentReference","exists","QueryDocumentSnapshot$1","fromFirestore","convertValue","_this$_document$data$","_this$_document","get","field","__PRIVATE_fieldPathFromArgument","__PRIVATE_validateHasExplicitOrderByForLimitToLast","limitType","explicitOrderBy","FirestoreError","C","UNIMPLEMENTED","AppliableConstraint","QueryConstraint","_len","Array","push","concat","__PRIVATE_validateQueryConstraintArray","filter","QueryCompositeFilterConstraint","QueryFieldFilterConstraint","INVALID_ARGUMENT","_apply","_field","_op","_value","_create","_parse","__PRIVATE_validateNewFieldFilter","_query","Query","firestore","converter","__PRIVATE_queryWithAddedFilter","__PRIVATE_newUserDataReader","__PRIVATE_newQueryFilter","a","o","i","isKeyField","__PRIVATE_validateDisjunctiveFilterElements","__PRIVATE_parseDocumentIdValue","arrayValue","values","__PRIVATE_parseQueryValue","u","FieldFilter","create","_databaseId","where","_queryConstraints","map","getFilters","CompositeFilter","_getOperator","__PRIVATE_validateNewFilter","getFlattenedFilters","_getQueryConstraints","or","_len2","_key2","forEach","__PRIVATE_validateQueryFilterConstraint","and","_len3","_key3","QueryOrderByConstraint","_direction","__PRIVATE_newQueryOrderBy","startAt","endAt","OrderBy","__PRIVATE_queryWithAddedOrderBy","orderBy","QueryLimitConstraint","_limit","_limitType","__PRIVATE_queryWithLimit","limit","__PRIVATE_validatePositiveNumber","limitToLast","QueryStartAtConstraint","_docOrFields","_inclusive","__PRIVATE_newQueryBoundFromDocOrFields","__PRIVATE_queryWithStartAt","_len4","_key4","startAfter","_len5","_key5","QueryEndAtConstraint","__PRIVATE_queryWithEndAt","endBefore","_len6","_key6","_len7","_key7","getModularInstance","__PRIVATE_newQueryBoundFromDocument","NOT_FOUND","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_refValue","key","__PRIVATE_isServerTimestamp","canonicalString","Bound","__PRIVATE_newQueryBoundFromFields","__PRIVATE_isCollectionGroupQuery","indexOf","child","ResourcePath","fromString","DocumentKey","isDocumentKey","__PRIVATE_valueDescription","isArray","toString","__PRIVATE_findOpInsideFilters","op","filters","__PRIVATE_conflictingOps","__PRIVATE_applyFirestoreDataConverter","merge","mergeFields","toFirestore","__PRIVATE_LiteUserDataWriter","AbstractUserDataWriter","convertBytes","Bytes","convertReference","convertDocumentKey","sum","average","count","aggregateFieldEqual","_t$_internalFieldPath","_e$_internalFieldPath","aggregateQuerySnapshotEqual","queryEqual","deepEqual","getCountFromServer","getAggregateFromServer","__PRIVATE_cast","Firestore","ensureFirestoreConfigured","__PRIVATE_mapToArray","__PRIVATE_AggregateImpl","__PRIVATE_firestoreClientRunAggregateQuery","then","__PRIVATE_convertToAggregateQuerySnapshot","__PRIVATE_ExpUserDataWriter","__PRIVATE_MemoryLocalCacheImpl","kind","_onlineComponentProvider","OnlineComponentProvider","provider","_offlineComponentProvider","garbageCollector","build","__PRIVATE_LruGcMemoryOfflineComponentProvider","toJSON","__PRIVATE_PersistentLocalCacheImpl","tabManager","_initialize","persistentSingleTabManager","__PRIVATE_MemoryEagerGarbageCollectorImpl","__PRIVATE_MemoryOfflineComponentProvider","__PRIVATE_MemoryLruGarbageCollectorImpl","memoryEagerGarbageCollector","memoryLruGarbageCollector","cacheSizeBytes","memoryLocalCache","persistentLocalCache","__PRIVATE_SingleTabManagerImpl","forceOwnership","__PRIVATE_IndexedDbOfflineComponentProvider","__PRIVATE_MultiTabManagerImpl","__PRIVATE_MultiTabOfflineComponentProvider","persistentMultipleTabManager","zt","SnapshotMetadata","hasPendingWrites","fromCache","isEqual","DocumentSnapshot","_firestoreImpl","metadata","QueryDocumentSnapshot","serverTimestamps","FAILED_PRECONDITION","_jsonSchemaVersion","bundle","bundleSource","bundleName","isValidDocument","isFoundDocument","documentSnapshotFromJSON","__PRIVATE_validateJSON","_jsonSchema","__PRIVATE_newSerializer","__PRIVATE_createBundleReaderSync","__PRIVATE_BundleLoader","getMetadata","documents","__PRIVATE_fromDocument","document","c","property","QuerySnapshot","_snapshot","docs","size","empty","call","mutatedKeys","has","docChanges","includeMetadataChanges","excludesMetadataChanges","_cachedChanges","_cachedChangesIncludeMetadataChanges","__PRIVATE_changesFromSnapshot","oldDocs","isEmpty","doc","oldIndex","newIndex","delete","add","__PRIVATE_resultChangeType","__PRIVATE_AutoId","newId","database","projectId","querySnapshotFromJSON","queries","__PRIVATE_fromBundledQuery","bundledQuery","DocumentSet","l","ViewSnapshot","fromInitialDocuments","__PRIVATE_documentKeySet","h","fail","snapshotEqual","Yt","maxAttempts","WriteBatch","_commitHandler","_mutations","_committed","_dataReader","set","_verifyNotCommitted","__PRIVATE_validateReference","__PRIVATE_parseSetData","toMutation","Precondition","none","update","_len8","_key8","FieldPath","__PRIVATE_parseUpdateVarargs","__PRIVATE_parseUpdateData","__PRIVATE_DeleteMutation","commit","Promise","resolve","Transaction$1","_transaction","lookup","isNoDocument","_len9","_key9","Transaction","runTransaction","_objectSpread","__PRIVATE_validateTransactionOptions","__PRIVATE_firestoreClientTransaction","getDoc","__PRIVATE_firestoreClientGetDocumentViaSnapshotListener","__PRIVATE_convertToDocSnapshot","getDocFromCache","__PRIVATE_firestoreClientGetDocumentFromLocalCache","hasLocalMutations","getDocFromServer","source","getDocs","__PRIVATE_firestoreClientGetDocumentsViaSnapshotListener","getDocsFromCache","__PRIVATE_firestoreClientGetDocumentsFromLocalCache","getDocsFromServer","setDoc","executeWrite","updateDoc","_len0","_key0","deleteDoc","addDoc","onSnapshot","_len1","_key1","_t$next","_t$error","_t$complete","next","bind","error","complete","__PRIVATE_newQueryForPath","__PRIVATE_firestoreClientListen","onSnapshotResume","__PRIVATE_normalizeSnapshotJsonFields","_len10","_key10","__PRIVATE_onSnapshotQuerySnapshotBundle","loadBundle","namedQuery","withConverter","catch","__PRIVATE_onSnapshotDocumentSnapshotBundle","fromPath","onSnapshotsInSync","__PRIVATE_firestoreClientAddSnapshotsInSyncListener","__PRIVATE_firestoreClientWrite","writeBatch","setIndexConfiguration","_uninitializedComponentsProvider","_offline","__PRIVATE_logWarn","__PRIVATE_parseIndexes","__PRIVATE_tryParseJson","JSON","parse","message","indexes","__PRIVATE_tryGetString","__PRIVATE_fieldPathFromDotSeparatedString","arrayConfig","IndexSegment","order","FieldIndex","UNKNOWN_ID","IndexState","__PRIVATE_firestoreClientSetIndexConfiguration","PersistentCacheIndexManager","getPersistentCacheIndexManager","_n$_uninitializedComp","Kt","enablePersistentCacheIndexAutoCreation","__PRIVATE_setPersistentCacheIndexAutoCreationEnabled","disablePersistentCacheIndexAutoCreation","deleteAllPersistentCacheIndexes","__PRIVATE_firestoreClientDeleteAllFieldIndexes","__PRIVATE_logDebug","__PRIVATE_firestoreClientSetPersistentCacheIndexAutoCreationEnabled","WeakMap","TestingHooks","Error","onExistenceFilterMismatch","__PRIVATE_TestingHooksSpiImpl","instance","Map","Xt","__PRIVATE_setTestingHooksSpi","Symbol","__PRIVATE_registerFirestore","__PRIVATE_setSDKVersion","SDK_VERSION","_registerComponent","Component","_ref","instanceIdentifier","options","getProvider","getImmediate","__PRIVATE_FirebaseAuthCredentialsProvider","__PRIVATE_FirebaseAppCheckTokenProvider","__PRIVATE_databaseIdFromApp","useFetchStreams","_setSettings","setMultipleInstances","registerVersion","Ut","Ht"],"sources":["C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\observer.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\aggregate_types.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\snapshot.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\query.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\reference_impl.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\aggregate.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\aggregate.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\cache_config.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\snapshot.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\platform\\browser\\snapshot_to_json.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\core\\transaction_options.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\write_batch.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\lite-api\\transaction.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\transaction.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\reference_impl.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\write_batch.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\index_configuration.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\api\\persistent_cache_index_manager.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\util\\testing_hooks.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\register.ts","C:\\Users\\51ngh\\Documents\\GITHUB_Repo\\Mediverse\\node_modules\\@firebase\\firestore\\src\\index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '../model/object_value';\nimport { FirestoreError } from '../util/error';\n\n/**\n * Observer/Subscribe interfaces.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: FirestoreError) => void;\nexport type CompleteFn = () => void;\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\nexport function isPartialObserver<T>(obj: unknown): obj is PartialObserver<T> {\n  return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj: unknown, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const object = obj as JsonObject<unknown>;\n  for (const method of methods) {\n    if (method in object && typeof object[method] === 'function') {\n      return true;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregateType } from '../core/aggregate';\nimport { ObjectValue } from '../model/object_value';\nimport { FieldPath as InternalFieldPath } from '../model/path';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Value\n} from '../protos/firestore_proto_api';\n\nimport { average, count, sum } from './aggregate';\nimport { DocumentData, Query } from './reference';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\nexport { AggregateType };\n\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class AggregateField<T> {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type = 'AggregateField';\n\n  /** Indicates the aggregation operation of this AggregateField. */\n  readonly aggregateType: AggregateType;\n\n  /**\n   * Create a new AggregateField<T>\n   * @param aggregateType - Specifies the type of aggregation operation to perform.\n   * @param _internalFieldPath - Optionally specifies the field that is aggregated.\n   * @internal\n   */\n  constructor(\n    aggregateType: AggregateType = 'count',\n    readonly _internalFieldPath?: InternalFieldPath\n  ) {\n    this.aggregateType = aggregateType;\n  }\n}\n\n/**\n * The union of all `AggregateField` types that are supported by Firestore.\n */\nexport type AggregateFieldType =\n  | ReturnType<typeof sum>\n  | ReturnType<typeof average>\n  | ReturnType<typeof count>;\n\n/**\n * Specifies a set of aggregations and their aliases.\n */\nexport interface AggregateSpec {\n  [field: string]: AggregateFieldType;\n}\n\n/**\n * A type whose keys are taken from an `AggregateSpec`, and whose values are the\n * result of the aggregation performed by the corresponding `AggregateField`\n * from the input `AggregateSpec`.\n */\nexport type AggregateSpecData<T extends AggregateSpec> = {\n  [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;\n};\n\n/**\n * The results of executing an aggregation query.\n */\nexport class AggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type = 'AggregateQuerySnapshot';\n\n  /**\n   * The underlying query over which the aggregations recorded in this\n   * `AggregateQuerySnapshot` were performed.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  /** @hideconstructor */\n  constructor(\n    query: Query<AppModelType, DbModelType>,\n    private readonly _userDataWriter: AbstractUserDataWriter,\n    private readonly _data: ApiClientObjectMap<Value>\n  ) {\n    this.query = query;\n  }\n\n  /**\n   * Returns the results of the aggregations performed over the underlying\n   * query.\n   *\n   * The keys of the returned object will be the same as those of the\n   * `AggregateSpec` object specified to the aggregation method, and the values\n   * will be the corresponding aggregation result.\n   *\n   * @returns The results of the aggregations performed over the underlying\n   * query.\n   */\n  data(): AggregateSpecData<AggregateSpecType> {\n    return this._userDataWriter.convertObjectMap(\n      this._data\n    ) as AggregateSpecData<AggregateSpecType>;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the snapshot as a proto value.\n   *\n   * @returns An `Object` containing all fields in the snapshot.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Wrap data in an ObjectValue to clone it.\n    const dataClone = new ObjectValue({\n      mapValue: { fields: this._data }\n    }).clone();\n\n    // Return the cloned value to prevent manipulation of the Snapshot's data\n    return dataClone.value.mapValue.fields!;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { arrayEquals } from '../util/misc';\n\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  queryEqual,\n  SetOptions,\n  WithFieldValue\n} from './reference';\nimport {\n  fieldPathFromArgument,\n  UntypedFirestoreDataConverter\n} from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * Converter used by `withConverter()` to transform user objects of type\n * `AppModelType` into Firestore data of type `DbModelType`.\n *\n * Using the converter allows you to specify generic type arguments when\n * storing and retrieving objects from Firestore.\n *\n * In this context, an \"AppModel\" is a class that is used in an application to\n * package together related information and functionality. Such a class could,\n * for example, have properties with complex, nested data types, properties used\n * for memoization, properties of types not supported by Firestore (such as\n * `symbol` and `bigint`), and helper functions that perform compound\n * operations. Such classes are not suitable and/or possible to store into a\n * Firestore database. Instead, instances of such classes need to be converted\n * to \"plain old JavaScript objects\" (POJOs) with exclusively primitive\n * properties, potentially nested inside other POJOs or arrays of POJOs. In this\n * context, this type is referred to as the \"DbModel\" and would be an object\n * suitable for persisting into Firestore. For convenience, applications can\n * implement `FirestoreDataConverter` and register the converter with Firestore\n * objects, such as `DocumentReference` or `Query`, to automatically convert\n * `AppModel` to `DbModel` when storing into Firestore, and convert `DbModel`\n * to `AppModel` when retrieving from Firestore.\n *\n * @example\n *\n * Simple Example\n *\n * ```typescript\n * const numberConverter = {\n *     toFirestore(value: WithFieldValue<number>) {\n *         return { value };\n *     },\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions) {\n *         return snapshot.data(options).value as number;\n *     }\n * };\n *\n * async function simpleDemo(db: Firestore): Promise<void> {\n *     const documentRef = doc(db, 'values/value123').withConverter(numberConverter);\n *\n *     // converters are used with `setDoc`, `addDoc`, and `getDoc`\n *     await setDoc(documentRef, 42);\n *     const snapshot1 = await getDoc(documentRef);\n *     assertEqual(snapshot1.data(), 42);\n *\n *     // converters are not used when writing data with `updateDoc`\n *     await updateDoc(documentRef, { value: 999 });\n *     const snapshot2 = await getDoc(documentRef);\n *     assertEqual(snapshot2.data(), 999);\n * }\n * ```\n *\n * Advanced Example\n *\n * ```typescript\n * // The Post class is a model that is used by our application.\n * // This class may have properties and methods that are specific\n * // to our application execution, which do not need to be persisted\n * // to Firestore.\n * class Post {\n *     constructor(\n *         readonly title: string,\n *         readonly author: string,\n *         readonly lastUpdatedMillis: number\n *     ) {}\n *     toString(): string {\n *         return `${this.title} by ${this.author}`;\n *     }\n * }\n *\n * // The PostDbModel represents how we want our posts to be stored\n * // in Firestore. This DbModel has different properties (`ttl`,\n * // `aut`, and `lut`) from the Post class we use in our application.\n * interface PostDbModel {\n *     ttl: string;\n *     aut: { firstName: string; lastName: string };\n *     lut: Timestamp;\n * }\n *\n * // The `PostConverter` implements `FirestoreDataConverter` and specifies\n * // how the Firestore SDK can convert `Post` objects to `PostDbModel`\n * // objects and vice versa.\n * class PostConverter implements FirestoreDataConverter<Post, PostDbModel> {\n *     toFirestore(post: WithFieldValue<Post>): WithFieldValue<PostDbModel> {\n *         return {\n *             ttl: post.title,\n *             aut: this._autFromAuthor(post.author),\n *             lut: this._lutFromLastUpdatedMillis(post.lastUpdatedMillis)\n *         };\n *     }\n *\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): Post {\n *         const data = snapshot.data(options) as PostDbModel;\n *         const author = `${data.aut.firstName} ${data.aut.lastName}`;\n *         return new Post(data.ttl, author, data.lut.toMillis());\n *     }\n *\n *     _autFromAuthor(\n *         author: string | FieldValue\n *     ): { firstName: string; lastName: string } | FieldValue {\n *         if (typeof author !== 'string') {\n *             // `author` is a FieldValue, so just return it.\n *             return author;\n *         }\n *         const [firstName, lastName] = author.split(' ');\n *         return {firstName, lastName};\n *     }\n *\n *     _lutFromLastUpdatedMillis(\n *         lastUpdatedMillis: number | FieldValue\n *     ): Timestamp | FieldValue {\n *         if (typeof lastUpdatedMillis !== 'number') {\n *             // `lastUpdatedMillis` must be a FieldValue, so just return it.\n *             return lastUpdatedMillis;\n *         }\n *         return Timestamp.fromMillis(lastUpdatedMillis);\n *     }\n * }\n *\n * async function advancedDemo(db: Firestore): Promise<void> {\n *     // Create a `DocumentReference` with a `FirestoreDataConverter`.\n *     const documentRef = doc(db, 'posts/post123').withConverter(new PostConverter());\n *\n *     // The `data` argument specified to `setDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `Post`. Since the `data`\n *     // argument is typed as `WithFieldValue<Post>` rather than just `Post`,\n *     // this allows properties of the `data` argument to also be special\n *     // Firestore values that perform server-side mutations, such as\n *     // `arrayRemove()`, `deleteField()`, and `serverTimestamp()`.\n *     await setDoc(documentRef, {\n *         title: 'My Life',\n *         author: 'Foo Bar',\n *         lastUpdatedMillis: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `setDoc()` is _not_ compatible with `WithFieldValue<Post>`. This\n *     // type checking prevents the caller from specifying objects with incorrect\n *     // properties or property values.\n *     // @ts-expect-error \"Argument of type { ttl: string; } is not assignable\n *     // to parameter of type WithFieldValue<Post>\"\n *     await setDoc(documentRef, { ttl: 'The Title' });\n *\n *     // When retrieving a document with `getDoc()` the `DocumentSnapshot`\n *     // object's `data()` method returns a `Post`, rather than a generic object,\n *     // which would have been returned if the `DocumentReference` did _not_ have a\n *     // `FirestoreDataConverter` attached to it.\n *     const snapshot1: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post1: Post = snapshot1.data()!;\n *     if (post1) {\n *         assertEqual(post1.title, 'My Life');\n *         assertEqual(post1.author, 'Foo Bar');\n *     }\n *\n *     // The `data` argument specified to `updateDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `PostDbModel`. Note that\n *     // unlike `setDoc()`, whose `data` argument must be compatible with `Post`,\n *     // the `data` argument to `updateDoc()` must be compatible with\n *     // `PostDbModel`. Similar to `setDoc()`, since the `data` argument is typed\n *     // as `WithFieldValue<PostDbModel>` rather than just `PostDbModel`, this\n *     // allows properties of the `data` argument to also be those special\n *     // Firestore values, like `arrayRemove()`, `deleteField()`, and\n *     // `serverTimestamp()`.\n *     await updateDoc(documentRef, {\n *         'aut.firstName': 'NewFirstName',\n *         lut: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `updateDoc()` is _not_ compatible with `WithFieldValue<PostDbModel>`.\n *     // This type checking prevents the caller from specifying objects with\n *     // incorrect properties or property values.\n *     // @ts-expect-error \"Argument of type { title: string; } is not assignable\n *     // to parameter of type WithFieldValue<PostDbModel>\"\n *     await updateDoc(documentRef, { title: 'New Title' });\n *     const snapshot2: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post2: Post = snapshot2.data()!;\n *     if (post2) {\n *         assertEqual(post2.title, 'My Life');\n *         assertEqual(post2.author, 'NewFirstName Bar');\n *     }\n * }\n * ```\n */\nexport interface FirestoreDataConverter<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link @firebase/firestore/lite#(setDoc:1)},\n   * {@link @firebase/firestore/lite#(WriteBatch.set:1)} and\n   * {@link @firebase/firestore/lite#(Transaction.set:1)}.\n   *\n   * The `WithFieldValue<T>` type extends `T` to also allow FieldValues such as\n   * {@link (deleteField:1)} to be used as property values.\n   */\n  toFirestore(\n    modelObject: WithFieldValue<AppModelType>\n  ): WithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link @firebase/firestore/lite#(setDoc:1)},\n   * {@link @firebase/firestore/lite#(WriteBatch.set:1)} and\n   * {@link @firebase/firestore/lite#(Transaction.set:1)} with `merge:true`\n   * or `mergeFields`.\n   *\n   * The `PartialWithFieldValue<T>` type extends `Partial<T>` to allow\n   * FieldValues such as {@link (arrayUnion:1)} to be used as property values.\n   * It also supports nested `Partial` by allowing nested fields to be\n   * omitted.\n   */\n  toFirestore(\n    modelObject: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): PartialWithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert Firestore data into an object of\n   * type `AppModelType`. You can access your data by calling:\n   * `snapshot.data()`.\n   *\n   *\n   * Generally, the data returned from `snapshot.data()` can be cast to\n   * `DbModelType`; however, this is not guaranteed because Firestore does not\n   * enforce a schema on the database. For example, writes from a previous\n   * version of the application or writes from another client that did not use a\n   * type converter could have written data with different properties and/or\n   * property types. The implementation will need to choose whether to\n   * gracefully recover from non-conforming data or throw an error.\n   *\n   * @param snapshot - A `QueryDocumentSnapshot` containing your data and\n   * metadata.\n   */\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>\n  ): AppModelType;\n}\n\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nexport class DocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  // Note: This class is stripped down version of the DocumentSnapshot in\n  // the legacy SDK. The changes are:\n  // - No support for SnapshotMetadata.\n  // - No support for SnapshotOptions.\n\n  /** @hideconstructor protected */\n  constructor(\n    public _firestore: Firestore,\n    public _userDataWriter: AbstractUserDataWriter,\n    public _key: DocumentKey,\n    public _document: Document | null,\n    public _converter: UntypedFirestoreDataConverter<\n      AppModelType,\n      DbModelType\n    > | null\n  ) {}\n\n  /** Property of the `DocumentSnapshot` that provides the document's ID. */\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  /**\n   * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n   */\n  get ref(): DocumentReference<AppModelType, DbModelType> {\n    return new DocumentReference<AppModelType, DbModelType>(\n      this._firestore,\n      this._converter,\n      this._key\n    );\n  }\n\n  /**\n   * Signals whether or not the document at the snapshot's location exists.\n   *\n   * @returns true if the document exists.\n   */\n  exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType> {\n    return this._document !== null;\n  }\n\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  data(): AppModelType | undefined {\n    if (!this._document) {\n      return undefined;\n    } else if (this._converter) {\n      // We only want to use the converter and create a new DocumentSnapshot\n      // if a converter has been provided.\n      const snapshot = new QueryDocumentSnapshot(\n        this._firestore,\n        this._userDataWriter,\n        this._key,\n        this._document,\n        /* converter= */ null\n      );\n      return this._converter.fromFirestore(snapshot);\n    } else {\n      return this._userDataWriter.convertValue(\n        this._document.data.value\n      ) as AppModelType;\n    }\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the document as a proto Value. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  _fieldsProto():\n    | { [key: string]: firestoreV1ApiClientInterfaces.Value }\n    | undefined {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._document?.data.clone().value.mapValue.fields ?? undefined;\n  }\n\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath): any {\n    if (this._document) {\n      const value = this._document.data.field(\n        fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n      );\n      if (value !== null) {\n        return this._userDataWriter.convertValue(value);\n      }\n    }\n    return undefined;\n  }\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nexport class QueryDocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends DocumentSnapshot<AppModelType, DbModelType> {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * @override\n   * @returns An `Object` containing all fields in the document.\n   */\n  data(): AppModelType {\n    return super.data() as AppModelType;\n  }\n}\n\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nexport class QuerySnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * The query on which you called {@link getDocs} in order to get this\n   * `QuerySnapshot`.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  /** @hideconstructor */\n  constructor(\n    _query: Query<AppModelType, DbModelType>,\n    readonly _docs: Array<QueryDocumentSnapshot<AppModelType, DbModelType>>\n  ) {\n    this.query = _query;\n  }\n\n  /** An array of all the documents in the `QuerySnapshot`. */\n  get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>> {\n    return [...this._docs];\n  }\n\n  /** The number of documents in the `QuerySnapshot`. */\n  get size(): number {\n    return this.docs.length;\n  }\n\n  /** True if there are no documents in the `QuerySnapshot`. */\n  get empty(): boolean {\n    return this.docs.length === 0;\n  }\n\n  /**\n   * Enumerates all of the documents in the `QuerySnapshot`.\n   *\n   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n   * each document in the snapshot.\n   * @param thisArg - The `this` binding for the callback.\n   */\n  forEach(\n    callback: (\n      result: QueryDocumentSnapshot<AppModelType, DbModelType>\n    ) => void,\n    thisArg?: unknown\n  ): void {\n    this._docs.forEach(callback, thisArg);\n  }\n}\n\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nexport function snapshotEqual<AppModelType, DbModelType extends DocumentData>(\n  left:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>,\n  right:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>\n): boolean {\n  left = getModularInstance(left);\n  right = getModularInstance(right);\n\n  if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      left._key.isEqual(right._key) &&\n      (left._document === null\n        ? right._document === null\n        : left._document.isEqual(right._document)) &&\n      left._converter === right._converter\n    );\n  } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n    return (\n      queryEqual(left.query, right.query) &&\n      arrayEquals(left.docs, right.docs, snapshotEqual)\n    );\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Bound } from '../core/bound';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  CompositeFilter,\n  CompositeOperator,\n  FieldFilter,\n  Filter,\n  Operator\n} from '../core/filter';\nimport { Direction, OrderBy } from '../core/order_by';\nimport {\n  isCollectionGroupQuery,\n  LimitType,\n  Query as InternalQuery,\n  queryNormalizedOrderBy,\n  queryWithAddedFilter,\n  queryWithAddedOrderBy,\n  queryWithEndAt,\n  queryWithLimit,\n  queryWithStartAt\n} from '../core/query';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldPath as InternalFieldPath, ResourcePath } from '../model/path';\nimport { isServerTimestamp } from '../model/server_timestamps';\nimport { refValue } from '../model/values';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  validatePositiveNumber,\n  valueDescription\n} from '../util/input_validation';\n\nimport { FieldPath } from './field_path';\nimport { DocumentData, DocumentReference, Query } from './reference';\nimport { DocumentSnapshot } from './snapshot';\nimport {\n  fieldPathFromArgument,\n  newUserDataReader,\n  parseQueryValue,\n  UserDataReader\n} from './user_data_reader';\n\nexport function validateHasExplicitOrderByForLimitToLast(\n  query: InternalQuery\n): void {\n  if (\n    query.limitType === LimitType.Last &&\n    query.explicitOrderBy.length === 0\n  ) {\n    throw new FirestoreError(\n      Code.UNIMPLEMENTED,\n      'limitToLast() queries require specifying at least one orderBy() clause'\n    );\n  }\n}\n\n/** Describes the different query constraints available in this SDK. */\nexport type QueryConstraintType =\n  | 'where'\n  | 'orderBy'\n  | 'limit'\n  | 'limitToLast'\n  | 'startAt'\n  | 'startAfter'\n  | 'endAt'\n  | 'endBefore';\n\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nexport abstract class AppliableConstraint {\n  /**\n   * Takes the provided {@link Query} and returns a copy of the {@link Query} with this\n   * {@link AppliableConstraint} applied.\n   */\n  abstract _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType>;\n}\n\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nexport abstract class QueryConstraint extends AppliableConstraint {\n  /** The type of this query constraint */\n  abstract readonly type: QueryConstraintType;\n\n  /**\n   * Takes the provided {@link Query} and returns a copy of the {@link Query} with this\n   * {@link AppliableConstraint} applied.\n   */\n  abstract _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType>;\n}\n\n/**\n * Creates a new immutable instance of {@link Query} that is extended to also\n * include additional query constraints.\n *\n * @param query - The {@link Query} instance to use as a base for the new\n * constraints.\n * @param compositeFilter - The {@link QueryCompositeFilterConstraint} to\n * apply. Create {@link QueryCompositeFilterConstraint} using {@link and} or\n * {@link or}.\n * @param queryConstraints - Additional {@link QueryNonFilterConstraint}s to\n * apply (e.g. {@link orderBy}, {@link limit}).\n * @throws if any of the provided query constraints cannot be combined with the\n * existing or new constraints.\n */\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  compositeFilter: QueryCompositeFilterConstraint,\n  ...queryConstraints: QueryNonFilterConstraint[]\n): Query<AppModelType, DbModelType>;\n\n/**\n * Creates a new immutable instance of {@link Query} that is extended to also\n * include additional query constraints.\n *\n * @param query - The {@link Query} instance to use as a base for the new\n * constraints.\n * @param queryConstraints - The list of {@link QueryConstraint}s to apply.\n * @throws if any of the provided query constraints cannot be combined with the\n * existing or new constraints.\n */\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  ...queryConstraints: QueryConstraint[]\n): Query<AppModelType, DbModelType>;\n\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  queryConstraint: QueryCompositeFilterConstraint | QueryConstraint | undefined,\n  ...additionalQueryConstraints: Array<\n    QueryConstraint | QueryNonFilterConstraint\n  >\n): Query<AppModelType, DbModelType> {\n  let queryConstraints: AppliableConstraint[] = [];\n\n  if (queryConstraint instanceof AppliableConstraint) {\n    queryConstraints.push(queryConstraint);\n  }\n\n  queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n\n  validateQueryConstraintArray(queryConstraints);\n\n  for (const constraint of queryConstraints) {\n    query = constraint._apply(query);\n  }\n  return query;\n}\n\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nexport class QueryFieldFilterConstraint extends QueryConstraint {\n  /** The type of this query constraint */\n  readonly type = 'where';\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    private readonly _field: InternalFieldPath,\n    private _op: Operator,\n    private _value: unknown\n  ) {\n    super();\n  }\n\n  static _create(\n    _field: InternalFieldPath,\n    _op: Operator,\n    _value: unknown\n  ): QueryFieldFilterConstraint {\n    return new QueryFieldFilterConstraint(_field, _op, _value);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const filter = this._parse(query);\n    validateNewFieldFilter(query._query, filter);\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedFilter(query._query, filter)\n    );\n  }\n\n  _parse<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): FieldFilter {\n    const reader = newUserDataReader(query.firestore);\n    const filter = newQueryFilter(\n      query._query,\n      'where',\n      reader,\n      query.firestore._databaseId,\n      this._field,\n      this._op,\n      this._value\n    );\n    return filter;\n  }\n}\n\n/**\n * Filter conditions in a {@link where} clause are specified using the\n * strings '&lt;', '&lt;=', '==', '!=', '&gt;=', '&gt;', 'array-contains', 'in',\n * 'array-contains-any', and 'not-in'.\n */\nexport type WhereFilterOp =\n  | '<'\n  | '<='\n  | '=='\n  | '!='\n  | '>='\n  | '>'\n  | 'array-contains'\n  | 'in'\n  | 'array-contains-any'\n  | 'not-in';\n\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nexport function where(\n  fieldPath: string | FieldPath,\n  opStr: WhereFilterOp,\n  value: unknown\n): QueryFieldFilterConstraint {\n  const op = opStr as Operator;\n  const field = fieldPathFromArgument('where', fieldPath);\n  return QueryFieldFilterConstraint._create(field, op, value);\n}\n\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nexport class QueryCompositeFilterConstraint extends AppliableConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'or' | 'and',\n    private readonly _queryConstraints: QueryFilterConstraint[]\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'or' | 'and',\n    _queryConstraints: QueryFilterConstraint[]\n  ): QueryCompositeFilterConstraint {\n    return new QueryCompositeFilterConstraint(type, _queryConstraints);\n  }\n\n  _parse<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Filter {\n    const parsedFilters = this._queryConstraints\n      .map(queryConstraint => {\n        return queryConstraint._parse(query);\n      })\n      .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n\n    if (parsedFilters.length === 1) {\n      return parsedFilters[0];\n    }\n\n    return CompositeFilter.create(parsedFilters, this._getOperator());\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const parsedFilter = this._parse(query);\n    if (parsedFilter.getFilters().length === 0) {\n      // Return the existing query if not adding any more filters (e.g. an empty\n      // composite filter).\n      return query;\n    }\n    validateNewFilter(query._query, parsedFilter);\n\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedFilter(query._query, parsedFilter)\n    );\n  }\n\n  _getQueryConstraints(): readonly AppliableConstraint[] {\n    return this._queryConstraints;\n  }\n\n  _getOperator(): CompositeOperator {\n    return this.type === 'and' ? CompositeOperator.AND : CompositeOperator.OR;\n  }\n}\n\n/**\n * `QueryNonFilterConstraint` is a helper union type that represents\n * QueryConstraints which are used to narrow or order the set of documents,\n * but that do not explicitly filter on a document field.\n * `QueryNonFilterConstraint`s are created by invoking {@link orderBy},\n * {@link (startAt:1)}, {@link (startAfter:1)}, {@link (endBefore:1)}, {@link (endAt:1)},\n * {@link limit} or {@link limitToLast} and can then be passed to {@link (query:1)}\n * to create a new query instance that also contains the `QueryConstraint`.\n */\nexport type QueryNonFilterConstraint =\n  | QueryOrderByConstraint\n  | QueryLimitConstraint\n  | QueryStartAtConstraint\n  | QueryEndAtConstraint;\n\n/**\n * `QueryFilterConstraint` is a helper union type that represents\n * {@link QueryFieldFilterConstraint} and {@link QueryCompositeFilterConstraint}.\n */\nexport type QueryFilterConstraint =\n  | QueryFieldFilterConstraint\n  | QueryCompositeFilterConstraint;\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nexport function or(\n  ...queryConstraints: QueryFilterConstraint[]\n): QueryCompositeFilterConstraint {\n  // Only support QueryFilterConstraints\n  queryConstraints.forEach(queryConstraint =>\n    validateQueryFilterConstraint('or', queryConstraint)\n  );\n\n  return QueryCompositeFilterConstraint._create(\n    CompositeOperator.OR,\n    queryConstraints as QueryFilterConstraint[]\n  );\n}\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nexport function and(\n  ...queryConstraints: QueryFilterConstraint[]\n): QueryCompositeFilterConstraint {\n  // Only support QueryFilterConstraints\n  queryConstraints.forEach(queryConstraint =>\n    validateQueryFilterConstraint('and', queryConstraint)\n  );\n\n  return QueryCompositeFilterConstraint._create(\n    CompositeOperator.AND,\n    queryConstraints as QueryFilterConstraint[]\n  );\n}\n\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nexport class QueryOrderByConstraint extends QueryConstraint {\n  /** The type of this query constraint */\n  readonly type = 'orderBy';\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    private readonly _field: InternalFieldPath,\n    private _direction: Direction\n  ) {\n    super();\n  }\n\n  static _create(\n    _field: InternalFieldPath,\n    _direction: Direction\n  ): QueryOrderByConstraint {\n    return new QueryOrderByConstraint(_field, _direction);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedOrderBy(query._query, orderBy)\n    );\n  }\n}\n\n/**\n * The direction of a {@link orderBy} clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n */\nexport type OrderByDirection = 'desc' | 'asc';\n\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nexport function orderBy(\n  fieldPath: string | FieldPath,\n  directionStr: OrderByDirection = 'asc'\n): QueryOrderByConstraint {\n  const direction = directionStr as Direction;\n  const path = fieldPathFromArgument('orderBy', fieldPath);\n  return QueryOrderByConstraint._create(path, direction);\n}\n\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nexport class QueryLimitConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'limit' | 'limitToLast',\n    private readonly _limit: number,\n    private readonly _limitType: LimitType\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'limit' | 'limitToLast',\n    _limit: number,\n    _limitType: LimitType\n  ): QueryLimitConstraint {\n    return new QueryLimitConstraint(type, _limit, _limitType);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithLimit(query._query, this._limit, this._limitType)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nexport function limit(limit: number): QueryLimitConstraint {\n  validatePositiveNumber('limit', limit);\n  return QueryLimitConstraint._create('limit', limit, LimitType.First);\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nexport function limitToLast(limit: number): QueryLimitConstraint {\n  validatePositiveNumber('limitToLast', limit);\n  return QueryLimitConstraint._create('limitToLast', limit, LimitType.Last);\n}\n\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nexport class QueryStartAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'startAt' | 'startAfter',\n    private readonly _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    private readonly _inclusive: boolean\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'startAt' | 'startAfter',\n    _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    _inclusive: boolean\n  ): QueryStartAtConstraint {\n    return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const bound = newQueryBoundFromDocOrFields(\n      query,\n      this.type,\n      this._docOrFields,\n      this._inclusive\n    );\n    return new Query<AppModelType, DbModelType>(\n      query.firestore,\n      query.converter,\n      queryWithStartAt(query._query, bound)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start at the provided document (inclusive). The starting position is relative\n * to the order of the query. The document must contain all of the fields\n * provided in the `orderBy` of this query.\n *\n * @param snapshot - The snapshot of the document to start at.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`.\n */\nexport function startAt<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryStartAtConstraint;\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start at the provided fields relative to the order of the query. The order of\n * the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to start this query at, in order\n * of the query's order by.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`.\n */\nexport function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;\nexport function startAt<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryStartAtConstraint {\n  return QueryStartAtConstraint._create(\n    'startAt',\n    docOrFields,\n    /*inclusive=*/ true\n  );\n}\n\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start after the provided document (exclusive). The starting position is\n * relative to the order of the query. The document must contain all of the\n * fields provided in the orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to start after.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`\n */\nexport function startAfter<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryStartAtConstraint;\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start after the provided fields relative to the order of the query. The order\n * of the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to start this query after, in order\n * of the query's order by.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`\n */\nexport function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;\nexport function startAfter<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryStartAtConstraint {\n  return QueryStartAtConstraint._create(\n    'startAfter',\n    docOrFields,\n    /*inclusive=*/ false\n  );\n}\n\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nexport class QueryEndAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'endBefore' | 'endAt',\n    private readonly _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    private readonly _inclusive: boolean\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'endBefore' | 'endAt',\n    _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    _inclusive: boolean\n  ): QueryEndAtConstraint {\n    return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const bound = newQueryBoundFromDocOrFields(\n      query,\n      this.type,\n      this._docOrFields,\n      this._inclusive\n    );\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithEndAt(query._query, bound)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end\n * before the provided document (exclusive). The end position is relative to the\n * order of the query. The document must contain all of the fields provided in\n * the orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to end before.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endBefore<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryEndAtConstraint;\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end\n * before the provided fields relative to the order of the query. The order of\n * the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to end this query before, in order\n * of the query's order by.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;\nexport function endBefore<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryEndAtConstraint {\n  return QueryEndAtConstraint._create(\n    'endBefore',\n    docOrFields,\n    /*inclusive=*/ false\n  );\n}\n\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end at\n * the provided document (inclusive). The end position is relative to the order\n * of the query. The document must contain all of the fields provided in the\n * orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to end at.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endAt<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryEndAtConstraint;\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end at\n * the provided fields relative to the order of the query. The order of the field\n * values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to end this query at, in order\n * of the query's order by.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;\nexport function endAt<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryEndAtConstraint {\n  return QueryEndAtConstraint._create(\n    'endAt',\n    docOrFields,\n    /*inclusive=*/ true\n  );\n}\n\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  methodName: string,\n  docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>,\n  inclusive: boolean\n): Bound {\n  docOrFields[0] = getModularInstance(docOrFields[0]);\n\n  if (docOrFields[0] instanceof DocumentSnapshot) {\n    return newQueryBoundFromDocument(\n      query._query,\n      query.firestore._databaseId,\n      methodName,\n      docOrFields[0]._document,\n      inclusive\n    );\n  } else {\n    const reader = newUserDataReader(query.firestore);\n    return newQueryBoundFromFields(\n      query._query,\n      query.firestore._databaseId,\n      reader,\n      methodName,\n      docOrFields,\n      inclusive\n    );\n  }\n}\n\nexport function newQueryFilter(\n  query: InternalQuery,\n  methodName: string,\n  dataReader: UserDataReader,\n  databaseId: DatabaseId,\n  fieldPath: InternalFieldPath,\n  op: Operator,\n  value: unknown\n): FieldFilter {\n  let fieldValue: ProtoValue;\n  if (fieldPath.isKeyField()) {\n    if (op === Operator.ARRAY_CONTAINS || op === Operator.ARRAY_CONTAINS_ANY) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. You can't perform '${op}' queries on documentId().`\n      );\n    } else if (op === Operator.IN || op === Operator.NOT_IN) {\n      validateDisjunctiveFilterElements(value, op);\n      const referenceList: ProtoValue[] = [];\n      for (const arrayValue of value as ProtoValue[]) {\n        referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n      }\n      fieldValue = { arrayValue: { values: referenceList } };\n    } else {\n      fieldValue = parseDocumentIdValue(databaseId, query, value);\n    }\n  } else {\n    if (\n      op === Operator.IN ||\n      op === Operator.NOT_IN ||\n      op === Operator.ARRAY_CONTAINS_ANY\n    ) {\n      validateDisjunctiveFilterElements(value, op);\n    }\n    fieldValue = parseQueryValue(\n      dataReader,\n      methodName,\n      value,\n      /* allowArrays= */ op === Operator.IN || op === Operator.NOT_IN\n    );\n  }\n  const filter = FieldFilter.create(fieldPath, op, fieldValue);\n  return filter;\n}\n\nexport function newQueryOrderBy(\n  query: InternalQuery,\n  fieldPath: InternalFieldPath,\n  direction: Direction\n): OrderBy {\n  if (query.startAt !== null) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid query. You must not call startAt() or startAfter() before ' +\n        'calling orderBy().'\n    );\n  }\n  if (query.endAt !== null) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid query. You must not call endAt() or endBefore() before ' +\n        'calling orderBy().'\n    );\n  }\n  const orderBy = new OrderBy(fieldPath, direction);\n  return orderBy;\n}\n\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nexport function newQueryBoundFromDocument(\n  query: InternalQuery,\n  databaseId: DatabaseId,\n  methodName: string,\n  doc: Document | null,\n  inclusive: boolean\n): Bound {\n  if (!doc) {\n    throw new FirestoreError(\n      Code.NOT_FOUND,\n      `Can't use a DocumentSnapshot that doesn't exist for ` +\n        `${methodName}().`\n    );\n  }\n\n  const components: ProtoValue[] = [];\n\n  // Because people expect to continue/end a query at the exact document\n  // provided, we need to use the implicit sort order rather than the explicit\n  // sort order, because it's guaranteed to contain the document key. That way\n  // the position becomes unambiguous and the query continues/ends exactly at\n  // the provided document. Without the key (by using the explicit sort\n  // orders), multiple documents could match the position, yielding duplicate\n  // results.\n  for (const orderBy of queryNormalizedOrderBy(query)) {\n    if (orderBy.field.isKeyField()) {\n      components.push(refValue(databaseId, doc.key));\n    } else {\n      const value = doc.data.field(orderBy.field);\n      if (isServerTimestamp(value)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. You are trying to start or end a query using a ' +\n            'document for which the field \"' +\n            orderBy.field +\n            '\" is an uncommitted server timestamp. (Since the value of ' +\n            'this field is unknown, you cannot start/end a query with it.)'\n        );\n      } else if (value !== null) {\n        components.push(value);\n      } else {\n        const field = orderBy.field.canonicalString();\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. You are trying to start or end a query using a ` +\n            `document for which the field '${field}' (used as the ` +\n            `orderBy) does not exist.`\n        );\n      }\n    }\n  }\n  return new Bound(components, inclusive);\n}\n\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nexport function newQueryBoundFromFields(\n  query: InternalQuery,\n  databaseId: DatabaseId,\n  dataReader: UserDataReader,\n  methodName: string,\n  values: unknown[],\n  inclusive: boolean\n): Bound {\n  // Use explicit order by's because it has to match the query the user made\n  const orderBy = query.explicitOrderBy;\n  if (values.length > orderBy.length) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Too many arguments provided to ${methodName}(). ` +\n        `The number of arguments must be less than or equal to the ` +\n        `number of orderBy() clauses`\n    );\n  }\n\n  const components: ProtoValue[] = [];\n  for (let i = 0; i < values.length; i++) {\n    const rawValue = values[i];\n    const orderByComponent = orderBy[i];\n    if (orderByComponent.field.isKeyField()) {\n      if (typeof rawValue !== 'string') {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. Expected a string for document ID in ` +\n            `${methodName}(), but got a ${typeof rawValue}`\n        );\n      }\n      if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection and ordering by documentId(), ` +\n            `the value passed to ${methodName}() must be a plain document ID, but ` +\n            `'${rawValue}' contains a slash.`\n        );\n      }\n      const path = query.path.child(ResourcePath.fromString(rawValue));\n      if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection group and ordering by ` +\n            `documentId(), the value passed to ${methodName}() must result in a ` +\n            `valid document path, but '${path}' is not because it contains an odd number ` +\n            `of segments.`\n        );\n      }\n      const key = new DocumentKey(path);\n      components.push(refValue(databaseId, key));\n    } else {\n      const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n      components.push(wrapped);\n    }\n  }\n\n  return new Bound(components, inclusive);\n}\n\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(\n  databaseId: DatabaseId,\n  query: InternalQuery,\n  documentIdValue: unknown\n): ProtoValue {\n  documentIdValue = getModularInstance(documentIdValue);\n\n  if (typeof documentIdValue === 'string') {\n    if (documentIdValue === '') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. When querying with documentId(), you ' +\n          'must provide a valid document ID, but it was an empty string.'\n      );\n    }\n    if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. When querying a collection by ` +\n          `documentId(), you must provide a plain document ID, but ` +\n          `'${documentIdValue}' contains a '/' character.`\n      );\n    }\n    const path = query.path.child(ResourcePath.fromString(documentIdValue));\n    if (!DocumentKey.isDocumentKey(path)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. When querying a collection group by ` +\n          `documentId(), the value provided must result in a valid document path, ` +\n          `but '${path}' is not because it has an odd number of segments (${path.length}).`\n      );\n    }\n    return refValue(databaseId, new DocumentKey(path));\n  } else if (documentIdValue instanceof DocumentReference) {\n    return refValue(databaseId, documentIdValue._key);\n  } else {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid query. When querying with documentId(), you must provide a valid ` +\n        `string or a DocumentReference, but it was: ` +\n        `${valueDescription(documentIdValue)}.`\n    );\n  }\n}\n\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(\n  value: unknown,\n  operator: Operator\n): void {\n  if (!Array.isArray(value) || value.length === 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid Query. A non-empty array is required for ' +\n        `'${operator.toString()}' filters.`\n    );\n  }\n}\n\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op: Operator): Operator[] {\n  switch (op) {\n    case Operator.NOT_EQUAL:\n      return [Operator.NOT_EQUAL, Operator.NOT_IN];\n    case Operator.ARRAY_CONTAINS_ANY:\n    case Operator.IN:\n      return [Operator.NOT_IN];\n    case Operator.NOT_IN:\n      return [\n        Operator.ARRAY_CONTAINS_ANY,\n        Operator.IN,\n        Operator.NOT_IN,\n        Operator.NOT_EQUAL\n      ];\n    default:\n      return [];\n  }\n}\n\nfunction validateNewFieldFilter(\n  query: InternalQuery,\n  fieldFilter: FieldFilter\n): void {\n  const conflictingOp = findOpInsideFilters(\n    query.filters,\n    conflictingOps(fieldFilter.op)\n  );\n  if (conflictingOp !== null) {\n    // Special case when it's a duplicate op to give a slightly clearer error message.\n    if (conflictingOp === fieldFilter.op) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You cannot use more than one ' +\n          `'${fieldFilter.op.toString()}' filter.`\n      );\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n          `with '${conflictingOp.toString()}' filters.`\n      );\n    }\n  }\n}\n\nfunction validateNewFilter(query: InternalQuery, filter: Filter): void {\n  let testQuery = query;\n  const subFilters = filter.getFlattenedFilters();\n  for (const subFilter of subFilters) {\n    validateNewFieldFilter(testQuery, subFilter);\n    testQuery = queryWithAddedFilter(testQuery, subFilter);\n  }\n}\n\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(\n  filters: Filter[],\n  operators: Operator[]\n): Operator | null {\n  for (const filter of filters) {\n    for (const fieldFilter of filter.getFlattenedFilters()) {\n      if (operators.indexOf(fieldFilter.op) >= 0) {\n        return fieldFilter.op;\n      }\n    }\n  }\n  return null;\n}\n\nexport function validateQueryFilterConstraint(\n  functionName: string,\n  queryConstraint: AppliableConstraint\n): void {\n  if (\n    !(queryConstraint instanceof QueryFieldFilterConstraint) &&\n    !(queryConstraint instanceof QueryCompositeFilterConstraint)\n  ) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`\n    );\n  }\n}\n\nfunction validateQueryConstraintArray(\n  queryConstraint: AppliableConstraint[]\n): void {\n  const compositeFilterCount = queryConstraint.filter(\n    filter => filter instanceof QueryCompositeFilterConstraint\n  ).length;\n  const fieldFilterCount = queryConstraint.filter(\n    filter => filter instanceof QueryFieldFilterConstraint\n  ).length;\n\n  if (\n    compositeFilterCount > 1 ||\n    (compositeFilterCount > 0 && fieldFilterCount > 0)\n  ) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'InvalidQuery. When using composite filters, you cannot use ' +\n        'more than one filter at the top level. Consider nesting the multiple ' +\n        'filters within an `and(...)` statement. For example: ' +\n        'change `query(query, where(...), or(...))` to ' +\n        '`query(query, and(where(...), or(...)))`.'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DocumentData as PublicDocumentData,\n  SetOptions as PublicSetOptions\n} from '@firebase/firestore-types';\nimport { getModularInstance } from '@firebase/util';\n\nimport { LimitType } from '../core/query';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport {\n  invokeBatchGetDocumentsRpc,\n  invokeCommitRpc,\n  invokeRunQueryRpc\n} from '../remote/datastore';\nimport { hardAssert } from '../util/assert';\nimport { ByteString } from '../util/byte_string';\nimport { cast } from '../util/input_validation';\n\nimport { Bytes } from './bytes';\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport { validateHasExplicitOrderByForLimitToLast } from './query';\nimport {\n  CollectionReference,\n  doc,\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport {\n  DocumentSnapshot,\n  QueryDocumentSnapshot,\n  QuerySnapshot\n} from './snapshot';\nimport {\n  newUserDataReader,\n  ParsedUpdateData,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UntypedFirestoreDataConverter\n} from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nexport function applyFirestoreDataConverter<T>(\n  converter: UntypedFirestoreDataConverter<T> | null,\n  value: WithFieldValue<T> | PartialWithFieldValue<T>,\n  options?: PublicSetOptions\n): PublicDocumentData {\n  let convertedValue;\n  if (converter) {\n    if (options && (options.merge || options.mergeFields)) {\n      // Cast to `any` in order to satisfy the union type constraint on\n      // toFirestore().\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      convertedValue = (converter as any).toFirestore(value, options);\n    } else {\n      convertedValue = converter.toFirestore(value as WithFieldValue<T>);\n    }\n  } else {\n    convertedValue = value as PublicDocumentData;\n  }\n  return convertedValue;\n}\n\nexport class LiteUserDataWriter extends AbstractUserDataWriter {\n  constructor(protected firestore: Firestore) {\n    super();\n  }\n\n  protected convertBytes(bytes: ByteString): Bytes {\n    return new Bytes(bytes);\n  }\n\n  protected convertReference(name: string): DocumentReference {\n    const key = this.convertDocumentKey(name, this.firestore._databaseId);\n    return new DocumentReference(this.firestore, /* converter= */ null, key);\n  }\n}\n\n/**\n * Reads the document referred to by the specified document reference.\n *\n * All documents are directly fetched from the server, even if the document was\n * previously read or modified. Recent modifications are only reflected in the\n * retrieved `DocumentSnapshot` if they have already been applied by the\n * backend. If the client is offline, the read fails. If you like to use\n * caching or see local modifications, please use the full Firestore SDK.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the current\n * document contents.\n */\nexport function getDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const datastore = getDatastore(reference.firestore);\n  const userDataWriter = new LiteUserDataWriter(reference.firestore);\n\n  return invokeBatchGetDocumentsRpc(datastore, [reference._key]).then(\n    result => {\n      hardAssert(\n        result.length === 1,\n        0x3d02,\n        'Expected a single document result'\n      );\n      const document = result[0];\n      return new DocumentSnapshot<AppModelType, DbModelType>(\n        reference.firestore,\n        userDataWriter,\n        reference._key,\n        document.isFoundDocument() ? document : null,\n        reference.converter\n      );\n    }\n  );\n}\n\n/**\n * Executes the query and returns the results as a {@link QuerySnapshot}.\n *\n * All queries are executed directly by the server, even if the query was\n * previously executed. Recent modifications are only reflected in the retrieved\n * results if they have already been applied by the backend. If the client is\n * offline, the operation fails. To see previously cached result and local\n * modifications, use the full Firestore SDK.\n *\n * @param query - The `Query` to execute.\n * @returns A Promise that will be resolved with the results of the query.\n */\nexport function getDocs<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  validateHasExplicitOrderByForLimitToLast(query._query);\n\n  const datastore = getDatastore(query.firestore);\n  const userDataWriter = new LiteUserDataWriter(query.firestore);\n  return invokeRunQueryRpc(datastore, query._query).then(result => {\n    const docs = result.map(\n      doc =>\n        new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          query.firestore,\n          userDataWriter,\n          doc.key,\n          doc,\n          query.converter\n        )\n    );\n\n    if (query._query.limitType === LimitType.Last) {\n      // Limit to last queries reverse the orderBy constraint that was\n      // specified by the user. As such, we need to reverse the order of the\n      // results to return the documents in the expected order.\n      docs.reverse();\n    }\n\n    return new QuerySnapshot<AppModelType, DbModelType>(query, docs);\n  });\n}\n\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<void>;\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created. If you provide `merge`\n * or `mergeFields`, the provided data can be merged into an existing document.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @param options - An object to configure the set behavior.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options: SetOptions\n): Promise<void>;\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options?: SetOptions\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data,\n    options\n  );\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'setDoc',\n    reference._key,\n    convertedValue,\n    reference.converter !== null,\n    options\n  );\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(reference._key, Precondition.none())\n  ]);\n}\n\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference`. The update will fail if applied to a document that does\n * not exist.\n *\n * The result of this update will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * update fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to update.\n * @param data - An object containing the fields and values with which to\n * update the document. Fields can contain dots to reference nested fields\n * within the document.\n * @throws Error - If the provided input is not valid Firestore data.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: UpdateData<DbModelType>\n): Promise<void>;\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference` The update will fail if applied to a document that does\n * not exist.\n *\n * Nested fields can be updated by providing dot-separated field path\n * strings or by providing `FieldPath` objects.\n *\n * The result of this update will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * update fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to update.\n * @param field - The first field to update.\n * @param value - The first value.\n * @param moreFieldsAndValues - Additional key value pairs.\n * @throws Error - If the provided input is not valid Firestore data.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  field: string | FieldPath,\n  value: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void>;\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n  value?: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const dataReader = newUserDataReader(reference.firestore);\n\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n  let parsed: ParsedUpdateData;\n  if (\n    typeof fieldOrUpdateData === 'string' ||\n    fieldOrUpdateData instanceof FieldPath\n  ) {\n    parsed = parseUpdateVarargs(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData,\n      value,\n      moreFieldsAndValues\n    );\n  } else {\n    parsed = parseUpdateData(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData\n    );\n  }\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(reference._key, Precondition.exists(true))\n  ]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * The deletion will only be reflected in document reads that occur after the\n * returned promise resolves. If the client is offline, the\n * delete fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to delete.\n * @returns A `Promise` resolved once the document has been successfully\n * deleted from the backend.\n */\nexport function deleteDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    new DeleteMutation(reference._key, Precondition.none())\n  ]);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend.\n */\nexport function addDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: CollectionReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<DocumentReference<AppModelType, DbModelType>> {\n  reference = cast<CollectionReference<AppModelType, DbModelType>>(\n    reference,\n    CollectionReference\n  );\n  const docRef = doc(reference);\n\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data as PartialWithFieldValue<AppModelType>\n  );\n\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'addDoc',\n    docRef._key,\n    convertedValue,\n    docRef.converter !== null,\n    {}\n  );\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(docRef._key, Precondition.exists(false))\n  ]).then(() => docRef);\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deepEqual } from '@firebase/util';\n\nimport { AggregateImpl } from '../core/aggregate';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { invokeRunAggregationQueryRpc } from '../remote/datastore';\nimport { cast } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\n\nimport {\n  AggregateField,\n  AggregateQuerySnapshot,\n  AggregateSpec\n} from './aggregate_types';\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport { DocumentData, Query, queryEqual } from './reference';\nimport { LiteUserDataWriter } from './reference_impl';\nimport { fieldPathFromArgument } from './user_data_reader';\n\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nexport function getCount<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<\n  AggregateQuerySnapshot<\n    { count: AggregateField<number> },\n    AppModelType,\n    DbModelType\n  >\n> {\n  const countQuerySpec: { count: AggregateField<number> } = {\n    count: count()\n  };\n\n  return getAggregate(query, countQuerySpec);\n}\n\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregate(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nexport function getAggregate<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  aggregateSpec: AggregateSpecType\n): Promise<\n  AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n> {\n  const firestore = cast(query.firestore, Firestore);\n  const datastore = getDatastore(firestore);\n\n  const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n    return new AggregateImpl(\n      alias,\n      aggregate.aggregateType,\n      aggregate._internalFieldPath\n    );\n  });\n\n  // Run the aggregation and convert the results\n  return invokeRunAggregationQueryRpc(\n    datastore,\n    query._query,\n    internalAggregates\n  ).then(aggregateResult =>\n    convertToAggregateQuerySnapshot(firestore, query, aggregateResult)\n  );\n}\n\nfunction convertToAggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  query: Query<AppModelType, DbModelType>,\n  aggregateResult: ApiClientObjectMap<Value>\n): AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType> {\n  const userDataWriter = new LiteUserDataWriter(firestore);\n  const querySnapshot = new AggregateQuerySnapshot<\n    AggregateSpecType,\n    AppModelType,\n    DbModelType\n  >(query, userDataWriter, aggregateResult);\n  return querySnapshot;\n}\n\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to sum across the result set.\n */\nexport function sum(field: string | FieldPath): AggregateField<number> {\n  return new AggregateField('sum', fieldPathFromArgument('sum', field));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to average across the result set.\n */\nexport function average(\n  field: string | FieldPath\n): AggregateField<number | null> {\n  return new AggregateField('avg', fieldPathFromArgument('average', field));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nexport function count(): AggregateField<number> {\n  return new AggregateField('count');\n}\n\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left - Compare this AggregateField to the `right`.\n * @param right - Compare this AggregateField to the `left`.\n */\nexport function aggregateFieldEqual(\n  left: AggregateField<unknown>,\n  right: AggregateField<unknown>\n): boolean {\n  return (\n    left instanceof AggregateField &&\n    right instanceof AggregateField &&\n    left.aggregateType === right.aggregateType &&\n    left._internalFieldPath?.canonicalString() ===\n      right._internalFieldPath?.canonicalString()\n  );\n}\n\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nexport function aggregateQuerySnapshotEqual<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  left: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>,\n  right: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n): boolean {\n  return (\n    queryEqual(left.query, right.query) && deepEqual(left.data(), right.data())\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregateImpl } from '../core/aggregate';\nimport { firestoreClientRunAggregateQuery } from '../core/firestore_client';\nimport { count } from '../lite-api/aggregate';\nimport {\n  AggregateField,\n  AggregateQuerySnapshot,\n  AggregateSpec\n} from '../lite-api/aggregate_types';\nimport { DocumentData, Query } from '../lite-api/reference';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { cast } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { ExpUserDataWriter } from './user_data_writer';\n\nexport {\n  aggregateQuerySnapshotEqual,\n  count,\n  sum,\n  average,\n  aggregateFieldEqual\n} from '../lite-api/aggregate';\n\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nexport function getCountFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<\n  AggregateQuerySnapshot<\n    { count: AggregateField<number> },\n    AppModelType,\n    DbModelType\n  >\n> {\n  const countQuerySpec: { count: AggregateField<number> } = {\n    count: count()\n  };\n\n  return getAggregateFromServer(query, countQuerySpec);\n}\n\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nexport function getAggregateFromServer<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  aggregateSpec: AggregateSpecType\n): Promise<\n  AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n> {\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n    return new AggregateImpl(\n      alias,\n      aggregate.aggregateType,\n      aggregate._internalFieldPath\n    );\n  });\n\n  // Run the aggregation and convert the results\n  return firestoreClientRunAggregateQuery(\n    client,\n    query._query,\n    internalAggregates\n  ).then(aggregateResult =>\n    convertToAggregateQuerySnapshot(firestore, query, aggregateResult)\n  );\n}\n\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult - Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  query: Query<AppModelType, DbModelType>,\n  aggregateResult: ApiClientObjectMap<Value>\n): AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType> {\n  const userDataWriter = new ExpUserDataWriter(firestore);\n  const querySnapshot = new AggregateQuerySnapshot<\n    AggregateSpecType,\n    AppModelType,\n    DbModelType\n  >(query, userDataWriter, aggregateResult);\n  return querySnapshot;\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexedDbOfflineComponentProvider,\n  LruGcMemoryOfflineComponentProvider,\n  MemoryOfflineComponentProvider,\n  MultiTabOfflineComponentProvider,\n  OfflineComponentProviderFactory,\n  OnlineComponentProviderFactory,\n  OnlineComponentProvider\n} from '../core/component_provider';\n\n/* eslint @typescript-eslint/consistent-type-definitions: [\"error\", \"type\"] */\n/**\n * Provides an in-memory cache to the SDK. This is the default cache unless explicitly\n * configured otherwise.\n *\n * To use, create an instance using the factory function {@link memoryLocalCache()}, then\n * set the instance to `FirestoreSettings.cache` and call `initializeFirestore` using\n * the settings object.\n */\nexport type MemoryLocalCache = {\n  kind: 'memory';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass MemoryLocalCacheImpl implements MemoryLocalCache {\n  kind: 'memory' = 'memory';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(settings?: MemoryCacheSettings) {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    if (settings?.garbageCollector) {\n      this._offlineComponentProvider =\n        settings.garbageCollector._offlineComponentProvider;\n    } else {\n      this._offlineComponentProvider = {\n        build: () => new LruGcMemoryOfflineComponentProvider(undefined)\n      };\n    }\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Provides a persistent cache backed by IndexedDb to the SDK.\n *\n * To use, create an instance using the factory function {@link persistentLocalCache()}, then\n * set the instance to `FirestoreSettings.cache` and call `initializeFirestore` using\n * the settings object.\n */\nexport type PersistentLocalCache = {\n  kind: 'persistent';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass PersistentLocalCacheImpl implements PersistentLocalCache {\n  kind: 'persistent' = 'persistent';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(settings: PersistentCacheSettings | undefined) {\n    let tabManager: PersistentTabManager;\n    if (settings?.tabManager) {\n      settings.tabManager._initialize(settings);\n      tabManager = settings.tabManager;\n    } else {\n      tabManager = persistentSingleTabManager(undefined);\n      tabManager._initialize(settings);\n    }\n    this._onlineComponentProvider = tabManager._onlineComponentProvider!;\n    this._offlineComponentProvider = tabManager._offlineComponentProvider!;\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Union type from all supported SDK cache layer.\n */\nexport type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;\n\n/**\n * Union type from all support garbage collectors for memory local cache.\n */\nexport type MemoryGarbageCollector =\n  | MemoryEagerGarbageCollector\n  | MemoryLruGarbageCollector;\n\n/**\n * A garbage collector deletes documents whenever they are not part of any\n * active queries, and have no local mutations attached to them.\n *\n * This collector tries to ensure lowest memory footprints from the SDK,\n * at the risk of documents not being cached for offline queries or for\n * direct queries to the cache.\n *\n * Use factory function {@link memoryEagerGarbageCollector()} to create an\n * instance of this collector.\n */\nexport type MemoryEagerGarbageCollector = {\n  kind: 'memoryEager';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\n/**\n * A garbage collector deletes Least-Recently-Used documents in multiple\n * batches.\n *\n * This collector is configured with a target size, and will only perform\n * collection when the cached documents exceed the target size. It avoids\n * querying backend repeated for the same query or document, at the risk\n * of having a larger memory footprint.\n *\n * Use factory function {@link memoryLruGarbageCollector()} to create a\n * instance of this collector.\n */\nexport type MemoryLruGarbageCollector = {\n  kind: 'memoryLru';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass MemoryEagerGarbageCollectorImpl implements MemoryEagerGarbageCollector {\n  kind: 'memoryEager' = 'memoryEager';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor() {\n    this._offlineComponentProvider = MemoryOfflineComponentProvider.provider;\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\nclass MemoryLruGarbageCollectorImpl implements MemoryLruGarbageCollector {\n  kind: 'memoryLru' = 'memoryLru';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(cacheSize?: number) {\n    this._offlineComponentProvider = {\n      build: () => new LruGcMemoryOfflineComponentProvider(cacheSize)\n    };\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nexport function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector {\n  return new MemoryEagerGarbageCollectorImpl();\n}\n\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nexport function memoryLruGarbageCollector(settings?: {\n  cacheSizeBytes?: number;\n}): MemoryLruGarbageCollector {\n  return new MemoryLruGarbageCollectorImpl(settings?.cacheSizeBytes);\n}\n\n/**\n * An settings object to configure an `MemoryLocalCache` instance.\n */\nexport type MemoryCacheSettings = {\n  /**\n   * The garbage collector to use, for the memory cache layer.\n   * A `MemoryEagerGarbageCollector` is used when this is undefined.\n   */\n  garbageCollector?: MemoryGarbageCollector;\n};\n\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nexport function memoryLocalCache(\n  settings?: MemoryCacheSettings\n): MemoryLocalCache {\n  return new MemoryLocalCacheImpl(settings);\n}\n\n/**\n * An settings object to configure an `PersistentLocalCache` instance.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nexport type PersistentCacheSettings = {\n  /**\n   * An approximate cache size threshold for the on-disk data. If the cache\n   * grows beyond this size, Firestore will start removing data that hasn't been\n   * recently used. The SDK does not guarantee that the cache will stay below\n   * that size, only that if the cache exceeds the given size, cleanup will be\n   * attempted.\n   *\n   * The default value is 40 MB. The threshold must be set to at least 1 MB, and\n   * can be set to `CACHE_SIZE_UNLIMITED` to disable garbage collection.\n   */\n  cacheSizeBytes?: number;\n\n  /**\n   * Specifies how multiple tabs/windows will be managed by the SDK.\n   */\n  tabManager?: PersistentTabManager;\n};\n\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nexport function persistentLocalCache(\n  settings?: PersistentCacheSettings\n): PersistentLocalCache {\n  return new PersistentLocalCacheImpl(settings);\n}\n\n/**\n * A tab manager supporting only one tab, no synchronization will be\n * performed across tabs.\n */\nexport type PersistentSingleTabManager = {\n  kind: 'persistentSingleTab';\n  /**\n   * @internal\n   */\n  _initialize: (\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ) => void;\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n};\n\nclass SingleTabManagerImpl implements PersistentSingleTabManager {\n  kind: 'persistentSingleTab' = 'persistentSingleTab';\n\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n\n  constructor(private forceOwnership?: boolean) {}\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n\n  /**\n   * @internal\n   */\n  _initialize(\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ): void {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    this._offlineComponentProvider = {\n      build: (onlineComponents: OnlineComponentProvider) =>\n        new IndexedDbOfflineComponentProvider(\n          onlineComponents,\n          settings?.cacheSizeBytes,\n          this.forceOwnership\n        )\n    };\n  }\n}\n\n/**\n * A tab manager supporting multiple tabs. SDK will synchronize queries and\n * mutations done across all tabs using the SDK.\n */\nexport type PersistentMultipleTabManager = {\n  kind: 'PersistentMultipleTab';\n  /**\n   * @internal\n   */\n  _initialize: (settings: Omit<PersistentCacheSettings, 'tabManager'>) => void;\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n};\n\nclass MultiTabManagerImpl implements PersistentMultipleTabManager {\n  kind: 'PersistentMultipleTab' = 'PersistentMultipleTab';\n\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n\n  /**\n   * @internal\n   */\n  _initialize(\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ): void {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    this._offlineComponentProvider = {\n      build: (onlineComponents: OnlineComponentProvider) =>\n        new MultiTabOfflineComponentProvider(\n          onlineComponents,\n          settings?.cacheSizeBytes\n        )\n    };\n  }\n}\n\n/**\n * A union of all available tab managers.\n */\nexport type PersistentTabManager =\n  | PersistentSingleTabManager\n  | PersistentMultipleTabManager;\n\n/**\n * Type to configure an `PersistentSingleTabManager` instance.\n */\nexport type PersistentSingleTabManagerSettings = {\n  /**\n   * Whether to force-enable persistent (IndexedDB) cache for the client. This\n   * cannot be used with multi-tab synchronization and is primarily intended for\n   * use with Web Workers. Setting this to `true` will enable IndexedDB, but cause\n   * other tabs using IndexedDB cache to fail.\n   */\n  forceOwnership?: boolean;\n};\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings - Configures the created tab manager.\n */\nexport function persistentSingleTabManager(\n  settings: PersistentSingleTabManagerSettings | undefined\n): PersistentSingleTabManager {\n  return new SingleTabManagerImpl(settings?.forceOwnership);\n}\n\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nexport function persistentMultipleTabManager(): PersistentMultipleTabManager {\n  return new MultiTabManagerImpl();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BundleLoader } from '../core/bundle_impl';\nimport { createBundleReaderSync } from '../core/firestore_client';\nimport { newQueryComparator } from '../core/query';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { FieldPath } from '../lite-api/field_path';\nimport {\n  DocumentData,\n  PartialWithFieldValue,\n  Query,\n  queryEqual,\n  SetOptions,\n  WithFieldValue\n} from '../lite-api/reference';\nimport { LiteUserDataWriter } from '../lite-api/reference_impl';\nimport {\n  DocumentSnapshot as LiteDocumentSnapshot,\n  FirestoreDataConverter as LiteFirestoreDataConverter\n} from '../lite-api/snapshot';\nimport {\n  fieldPathFromArgument,\n  UntypedFirestoreDataConverter\n} from '../lite-api/user_data_reader';\nimport { AbstractUserDataWriter } from '../lite-api/user_data_writer';\nimport { fromBundledQuery } from '../local/local_serializer';\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { ResourcePath } from '../model/path';\nimport { newSerializer } from '../platform/serializer';\nimport {\n  buildQuerySnapshotJsonBundle,\n  buildDocumentSnapshotJsonBundle\n} from '../platform/snapshot_to_json';\nimport { fromDocument } from '../remote/serializer';\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n// API extractor fails importing 'property' unless we also explicitly import 'Property'.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, unused-imports/no-unused-imports-ts\nimport { Property, property, validateJSON } from '../util/json_validation';\nimport { AutoId } from '../util/misc';\n\nimport { Firestore } from './database';\nimport { SnapshotListenOptions } from './reference_impl';\n\nconst NOT_SUPPORTED = 'NOT SUPPORTED';\n\n/**\n * Converter used by `withConverter()` to transform user objects of type\n * `AppModelType` into Firestore data of type `DbModelType`.\n *\n * Using the converter allows you to specify generic type arguments when\n * storing and retrieving objects from Firestore.\n *\n * In this context, an \"AppModel\" is a class that is used in an application to\n * package together related information and functionality. Such a class could,\n * for example, have properties with complex, nested data types, properties used\n * for memoization, properties of types not supported by Firestore (such as\n * `symbol` and `bigint`), and helper functions that perform compound\n * operations. Such classes are not suitable and/or possible to store into a\n * Firestore database. Instead, instances of such classes need to be converted\n * to \"plain old JavaScript objects\" (POJOs) with exclusively primitive\n * properties, potentially nested inside other POJOs or arrays of POJOs. In this\n * context, this type is referred to as the \"DbModel\" and would be an object\n * suitable for persisting into Firestore. For convenience, applications can\n * implement `FirestoreDataConverter` and register the converter with Firestore\n * objects, such as `DocumentReference` or `Query`, to automatically convert\n * `AppModel` to `DbModel` when storing into Firestore, and convert `DbModel`\n * to `AppModel` when retrieving from Firestore.\n *\n * @example\n *\n * Simple Example\n *\n * ```typescript\n * const numberConverter = {\n *     toFirestore(value: WithFieldValue<number>) {\n *         return { value };\n *     },\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions) {\n *         return snapshot.data(options).value as number;\n *     }\n * };\n *\n * async function simpleDemo(db: Firestore): Promise<void> {\n *     const documentRef = doc(db, 'values/value123').withConverter(numberConverter);\n *\n *     // converters are used with `setDoc`, `addDoc`, and `getDoc`\n *     await setDoc(documentRef, 42);\n *     const snapshot1 = await getDoc(documentRef);\n *     assertEqual(snapshot1.data(), 42);\n *\n *     // converters are not used when writing data with `updateDoc`\n *     await updateDoc(documentRef, { value: 999 });\n *     const snapshot2 = await getDoc(documentRef);\n *     assertEqual(snapshot2.data(), 999);\n * }\n * ```\n *\n * Advanced Example\n *\n * ```typescript\n * // The Post class is a model that is used by our application.\n * // This class may have properties and methods that are specific\n * // to our application execution, which do not need to be persisted\n * // to Firestore.\n * class Post {\n *     constructor(\n *         readonly title: string,\n *         readonly author: string,\n *         readonly lastUpdatedMillis: number\n *     ) {}\n *     toString(): string {\n *         return `${this.title} by ${this.author}`;\n *     }\n * }\n *\n * // The PostDbModel represents how we want our posts to be stored\n * // in Firestore. This DbModel has different properties (`ttl`,\n * // `aut`, and `lut`) from the Post class we use in our application.\n * interface PostDbModel {\n *     ttl: string;\n *     aut: { firstName: string; lastName: string };\n *     lut: Timestamp;\n * }\n *\n * // The `PostConverter` implements `FirestoreDataConverter` and specifies\n * // how the Firestore SDK can convert `Post` objects to `PostDbModel`\n * // objects and vice versa.\n * class PostConverter implements FirestoreDataConverter<Post, PostDbModel> {\n *     toFirestore(post: WithFieldValue<Post>): WithFieldValue<PostDbModel> {\n *         return {\n *             ttl: post.title,\n *             aut: this._autFromAuthor(post.author),\n *             lut: this._lutFromLastUpdatedMillis(post.lastUpdatedMillis)\n *         };\n *     }\n *\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): Post {\n *         const data = snapshot.data(options) as PostDbModel;\n *         const author = `${data.aut.firstName} ${data.aut.lastName}`;\n *         return new Post(data.ttl, author, data.lut.toMillis());\n *     }\n *\n *     _autFromAuthor(\n *         author: string | FieldValue\n *     ): { firstName: string; lastName: string } | FieldValue {\n *         if (typeof author !== 'string') {\n *             // `author` is a FieldValue, so just return it.\n *             return author;\n *         }\n *         const [firstName, lastName] = author.split(' ');\n *         return {firstName, lastName};\n *     }\n *\n *     _lutFromLastUpdatedMillis(\n *         lastUpdatedMillis: number | FieldValue\n *     ): Timestamp | FieldValue {\n *         if (typeof lastUpdatedMillis !== 'number') {\n *             // `lastUpdatedMillis` must be a FieldValue, so just return it.\n *             return lastUpdatedMillis;\n *         }\n *         return Timestamp.fromMillis(lastUpdatedMillis);\n *     }\n * }\n *\n * async function advancedDemo(db: Firestore): Promise<void> {\n *     // Create a `DocumentReference` with a `FirestoreDataConverter`.\n *     const documentRef = doc(db, 'posts/post123').withConverter(new PostConverter());\n *\n *     // The `data` argument specified to `setDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `Post`. Since the `data`\n *     // argument is typed as `WithFieldValue<Post>` rather than just `Post`,\n *     // this allows properties of the `data` argument to also be special\n *     // Firestore values that perform server-side mutations, such as\n *     // `arrayRemove()`, `deleteField()`, and `serverTimestamp()`.\n *     await setDoc(documentRef, {\n *         title: 'My Life',\n *         author: 'Foo Bar',\n *         lastUpdatedMillis: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `setDoc()` is _not_ compatible with `WithFieldValue<Post>`. This\n *     // type checking prevents the caller from specifying objects with incorrect\n *     // properties or property values.\n *     // @ts-expect-error \"Argument of type { ttl: string; } is not assignable\n *     // to parameter of type WithFieldValue<Post>\"\n *     await setDoc(documentRef, { ttl: 'The Title' });\n *\n *     // When retrieving a document with `getDoc()` the `DocumentSnapshot`\n *     // object's `data()` method returns a `Post`, rather than a generic object,\n *     // which would have been returned if the `DocumentReference` did _not_ have a\n *     // `FirestoreDataConverter` attached to it.\n *     const snapshot1: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post1: Post = snapshot1.data()!;\n *     if (post1) {\n *         assertEqual(post1.title, 'My Life');\n *         assertEqual(post1.author, 'Foo Bar');\n *     }\n *\n *     // The `data` argument specified to `updateDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `PostDbModel`. Note that\n *     // unlike `setDoc()`, whose `data` argument must be compatible with `Post`,\n *     // the `data` argument to `updateDoc()` must be compatible with\n *     // `PostDbModel`. Similar to `setDoc()`, since the `data` argument is typed\n *     // as `WithFieldValue<PostDbModel>` rather than just `PostDbModel`, this\n *     // allows properties of the `data` argument to also be those special\n *     // Firestore values, like `arrayRemove()`, `deleteField()`, and\n *     // `serverTimestamp()`.\n *     await updateDoc(documentRef, {\n *         'aut.firstName': 'NewFirstName',\n *         lut: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `updateDoc()` is _not_ compatible with `WithFieldValue<PostDbModel>`.\n *     // This type checking prevents the caller from specifying objects with\n *     // incorrect properties or property values.\n *     // @ts-expect-error \"Argument of type { title: string; } is not assignable\n *     // to parameter of type WithFieldValue<PostDbModel>\"\n *     await updateDoc(documentRef, { title: 'New Title' });\n *     const snapshot2: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post2: Post = snapshot2.data()!;\n *     if (post2) {\n *         assertEqual(post2.title, 'My Life');\n *         assertEqual(post2.author, 'NewFirstName Bar');\n *     }\n * }\n * ```\n */\nexport interface FirestoreDataConverter<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n> extends LiteFirestoreDataConverter<AppModelType, DbModelType> {\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. To use `set()`\n   * with `merge` and `mergeFields`, `toFirestore()` must be defined with\n   * `PartialWithFieldValue<AppModelType>`.\n   *\n   * The `WithFieldValue<T>` type extends `T` to also allow FieldValues such as\n   * {@link (deleteField:1)} to be used as property values.\n   */\n  toFirestore(\n    modelObject: WithFieldValue<AppModelType>\n  ): WithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link (setDoc:1)}, {@link (WriteBatch.set:1)} and\n   * {@link (Transaction.set:1)} with `merge:true` or `mergeFields`.\n   *\n   * The `PartialWithFieldValue<T>` type extends `Partial<T>` to allow\n   * FieldValues such as {@link (arrayUnion:1)} to be used as property values.\n   * It also supports nested `Partial` by allowing nested fields to be\n   * omitted.\n   */\n  toFirestore(\n    modelObject: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): PartialWithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert Firestore data into an object of\n   * type `AppModelType`. You can access your data by calling:\n   * `snapshot.data(options)`.\n   *\n   * Generally, the data returned from `snapshot.data()` can be cast to\n   * `DbModelType`; however, this is not guaranteed because Firestore does not\n   * enforce a schema on the database. For example, writes from a previous\n   * version of the application or writes from another client that did not use a\n   * type converter could have written data with different properties and/or\n   * property types. The implementation will need to choose whether to\n   * gracefully recover from non-conforming data or throw an error.\n   *\n   * To override this method, see {@link (FirestoreDataConverter.fromFirestore:1)}.\n   *\n   * @param snapshot - A `QueryDocumentSnapshot` containing your data and metadata.\n   * @param options - The `SnapshotOptions` from the initial call to `data()`.\n   */\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>,\n    options?: SnapshotOptions\n  ): AppModelType;\n}\n\n/**\n * Options that configure how data is retrieved from a `DocumentSnapshot` (for\n * example the desired behavior for server timestamps that have not yet been set\n * to their final value).\n */\nexport interface SnapshotOptions {\n  /**\n   * If set, controls the return value for server timestamps that have not yet\n   * been set to their final value.\n   *\n   * By specifying 'estimate', pending server timestamps return an estimate\n   * based on the local clock. This estimate will differ from the final value\n   * and cause these values to change once the server result becomes available.\n   *\n   * By specifying 'previous', pending timestamps will be ignored and return\n   * their previous value instead.\n   *\n   * If omitted or set to 'none', `null` will be returned by default until the\n   * server value becomes available.\n   */\n  readonly serverTimestamps?: 'estimate' | 'previous' | 'none';\n}\n\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nexport class SnapshotMetadata {\n  /**\n   * True if the snapshot contains the result of local writes (for example\n   * `set()` or `update()` calls) that have not yet been committed to the\n   * backend. If your listener has opted into metadata updates (via\n   * `SnapshotListenOptions`) you will receive another snapshot with\n   * `hasPendingWrites` equal to false once the writes have been committed to\n   * the backend.\n   */\n  readonly hasPendingWrites: boolean;\n\n  /**\n   * True if the snapshot was created from cached data rather than guaranteed\n   * up-to-date server data. If your listener has opted into metadata updates\n   * (via `SnapshotListenOptions`) you will receive another snapshot with\n   * `fromCache` set to false once the client has received up-to-date data from\n   * the backend.\n   */\n  readonly fromCache: boolean;\n\n  /** @hideconstructor */\n  constructor(hasPendingWrites: boolean, fromCache: boolean) {\n    this.hasPendingWrites = hasPendingWrites;\n    this.fromCache = fromCache;\n  }\n\n  /**\n   * Returns true if this `SnapshotMetadata` is equal to the provided one.\n   *\n   * @param other - The `SnapshotMetadata` to compare against.\n   * @returns true if this `SnapshotMetadata` is equal to the provided one.\n   */\n  isEqual(other: SnapshotMetadata): boolean {\n    return (\n      this.hasPendingWrites === other.hasPendingWrites &&\n      this.fromCache === other.fromCache\n    );\n  }\n}\n\n/**\n * The type of a `DocumentChange` may be 'added', 'removed', or 'modified'.\n */\nexport type DocumentChangeType = 'added' | 'removed' | 'modified';\n\n/**\n * A `DocumentChange` represents a change to the documents matching a query.\n * It contains the document affected and the type of change that occurred.\n */\nexport interface DocumentChange<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /** The type of change ('added', 'modified', or 'removed'). */\n  readonly type: DocumentChangeType;\n\n  /** The document affected by this change. */\n  readonly doc: QueryDocumentSnapshot<AppModelType, DbModelType>;\n\n  /**\n   * The index of the changed document in the result set immediately prior to\n   * this `DocumentChange` (i.e. supposing that all prior `DocumentChange` objects\n   * have been applied). Is `-1` for 'added' events.\n   */\n  readonly oldIndex: number;\n\n  /**\n   * The index of the changed document in the result set immediately after\n   * this `DocumentChange` (i.e. supposing that all prior `DocumentChange`\n   * objects and the current `DocumentChange` object have been applied).\n   * Is -1 for 'removed' events.\n   */\n  readonly newIndex: number;\n}\n\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nexport class DocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends LiteDocumentSnapshot<AppModelType, DbModelType> {\n  private readonly _firestoreImpl: Firestore;\n\n  /**\n   *  Metadata about the `DocumentSnapshot`, including information about its\n   *  source and local modifications.\n   */\n  readonly metadata: SnapshotMetadata;\n\n  /** @hideconstructor protected */\n  constructor(\n    readonly _firestore: Firestore,\n    userDataWriter: AbstractUserDataWriter,\n    key: DocumentKey,\n    document: Document | null,\n    metadata: SnapshotMetadata,\n    converter: UntypedFirestoreDataConverter<AppModelType, DbModelType> | null\n  ) {\n    super(_firestore, userDataWriter, key, document, converter);\n    this._firestoreImpl = _firestore;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Returns whether or not the data exists. True if the document exists.\n   */\n  exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType> {\n    return super.exists();\n  }\n\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document or `undefined` if\n   * the document doesn't exist.\n   */\n  data(options: SnapshotOptions = {}): AppModelType | undefined {\n    if (!this._document) {\n      return undefined;\n    } else if (this._converter) {\n      // We only want to use the converter and create a new DocumentSnapshot\n      // if a converter has been provided.\n      const snapshot = new QueryDocumentSnapshot(\n        this._firestore,\n        this._userDataWriter,\n        this._key,\n        this._document,\n        this.metadata,\n        /* converter= */ null\n      );\n      return this._converter.fromFirestore(snapshot, options);\n    } else {\n      return this._userDataWriter.convertValue(\n        this._document.data.value,\n        options.serverTimestamps\n      ) as AppModelType;\n    }\n  }\n\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * By default, a `serverTimestamp()` that has not yet been set to\n   * its final value will be returned as `null`. You can override this by\n   * passing an options object.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @param options - An options object to configure how the field is retrieved\n   * from the snapshot (for example the desired behavior for server timestamps\n   * that have not yet been set to their final value).\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath, options: SnapshotOptions = {}): any {\n    if (this._document) {\n      const value = this._document.data.field(\n        fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n      );\n      if (value !== null) {\n        return this._userDataWriter.convertValue(\n          value,\n          options.serverTimestamps\n        );\n      }\n    }\n    return undefined;\n  }\n\n  static _jsonSchemaVersion: string = 'firestore/documentSnapshot/1.0';\n  static _jsonSchema = {\n    type: property('string', DocumentSnapshot._jsonSchemaVersion),\n    bundleSource: property('string', 'DocumentSnapshot'),\n    bundleName: property('string'),\n    bundle: property('string')\n  };\n\n  /**\n   * Returns a JSON-serializable representation of this `DocumentSnapshot` instance.\n   *\n   * @returns a JSON representation of this object.  Throws a {@link FirestoreError} if this\n   * `DocumentSnapshot` has pending writes.\n   */\n  toJSON(): object {\n    if (this.metadata.hasPendingWrites) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n          'Await waitForPendingWrites() before invoking toJSON().'\n      );\n    }\n    const document = this._document;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result: any = {};\n    result['type'] = DocumentSnapshot._jsonSchemaVersion;\n    result['bundle'] = '';\n    result['bundleSource'] = 'DocumentSnapshot';\n    result['bundleName'] = this._key.toString();\n\n    if (\n      !document ||\n      !document.isValidDocument() ||\n      !document.isFoundDocument()\n    ) {\n      return result;\n    }\n    const documentData = this._userDataWriter.convertObjectMap(\n      document.data.value.mapValue.fields,\n      'previous'\n    );\n    result['bundle'] = buildDocumentSnapshotJsonBundle(\n      this._firestore,\n      document,\n      documentData,\n      this.ref.path\n    );\n    return result;\n  }\n}\n\n/**\n * Builds a `DocumentSnapshot` instance from a JSON object created by\n * {@link DocumentSnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `DocumentSnapshot` instance.\n * @returns an instance of {@link DocumentSnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function documentSnapshotFromJSON(\n  db: Firestore,\n  json: object\n): DocumentSnapshot;\n/**\n * Builds a `DocumentSnapshot` instance from a JSON object created by\n * {@link DocumentSnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `DocumentSnapshot` instance.\n * @param converter - Converts objects to and from Firestore.\n * @returns an instance of {@link DocumentSnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function documentSnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter: FirestoreDataConverter<AppModelType, DbModelType>\n): DocumentSnapshot<AppModelType, DbModelType>;\nexport function documentSnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter?: FirestoreDataConverter<AppModelType, DbModelType>\n): DocumentSnapshot<AppModelType, DbModelType> {\n  if (validateJSON(json, DocumentSnapshot._jsonSchema)) {\n    if (json.bundle === NOT_SUPPORTED) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'The provided JSON object was created in a client environment, which is not supported.'\n      );\n    }\n    // Parse the bundle data.\n    const serializer = newSerializer(db._databaseId);\n    const bundleReader = createBundleReaderSync(json.bundle, serializer);\n    const elements = bundleReader.getElements();\n    const bundleLoader: BundleLoader = new BundleLoader(\n      bundleReader.getMetadata(),\n      serializer\n    );\n    for (const element of elements) {\n      bundleLoader.addSizedElement(element);\n    }\n\n    // Ensure that we have the correct number of documents in the bundle.\n    const bundledDocuments = bundleLoader.documents;\n    if (bundledDocuments.length !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Expected bundle data to contain 1 document, but it contains ${bundledDocuments.length} documents.`\n      );\n    }\n\n    // Build out the internal document data.\n    const document = fromDocument(serializer, bundledDocuments[0].document!);\n    const documentKey = new DocumentKey(\n      ResourcePath.fromString(json.bundleName)\n    );\n\n    // Return the external facing DocumentSnapshot.\n    return new DocumentSnapshot(\n      db,\n      new LiteUserDataWriter(db),\n      documentKey,\n      document,\n      new SnapshotMetadata(\n        /* hasPendingWrites= */ false,\n        /* fromCache= */ false\n      ),\n      converter ? converter : null\n    );\n  }\n  throw new FirestoreError(\n    Code.INTERNAL,\n    'Unexpected error creating DocumentSnapshot from JSON.'\n  );\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nexport class QueryDocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends DocumentSnapshot<AppModelType, DbModelType> {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @override\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document.\n   */\n  data(options: SnapshotOptions = {}): AppModelType {\n    return super.data(options) as AppModelType;\n  }\n}\n\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nexport class QuerySnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * Metadata about this snapshot, concerning its source and if it has local\n   * modifications.\n   */\n  readonly metadata: SnapshotMetadata;\n\n  /**\n   * The query on which you called `get` or `onSnapshot` in order to get this\n   * `QuerySnapshot`.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  private _cachedChanges?: Array<DocumentChange<AppModelType, DbModelType>>;\n  private _cachedChangesIncludeMetadataChanges?: boolean;\n\n  /** @hideconstructor */\n  constructor(\n    readonly _firestore: Firestore,\n    readonly _userDataWriter: AbstractUserDataWriter,\n    query: Query<AppModelType, DbModelType>,\n    readonly _snapshot: ViewSnapshot\n  ) {\n    this.metadata = new SnapshotMetadata(\n      _snapshot.hasPendingWrites,\n      _snapshot.fromCache\n    );\n    this.query = query;\n  }\n\n  /** An array of all the documents in the `QuerySnapshot`. */\n  get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>> {\n    const result: Array<QueryDocumentSnapshot<AppModelType, DbModelType>> = [];\n    this.forEach(doc => result.push(doc));\n    return result;\n  }\n\n  /** The number of documents in the `QuerySnapshot`. */\n  get size(): number {\n    return this._snapshot.docs.size;\n  }\n\n  /** True if there are no documents in the `QuerySnapshot`. */\n  get empty(): boolean {\n    return this.size === 0;\n  }\n\n  /**\n   * Enumerates all of the documents in the `QuerySnapshot`.\n   *\n   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n   * each document in the snapshot.\n   * @param thisArg - The `this` binding for the callback.\n   */\n  forEach(\n    callback: (\n      result: QueryDocumentSnapshot<AppModelType, DbModelType>\n    ) => void,\n    thisArg?: unknown\n  ): void {\n    this._snapshot.docs.forEach(doc => {\n      callback.call(\n        thisArg,\n        new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          this._userDataWriter,\n          doc.key,\n          doc,\n          new SnapshotMetadata(\n            this._snapshot.mutatedKeys.has(doc.key),\n            this._snapshot.fromCache\n          ),\n          this.query.converter\n        )\n      );\n    });\n  }\n\n  /**\n   * Returns an array of the documents changes since the last snapshot. If this\n   * is the first snapshot, all documents will be in the list as 'added'\n   * changes.\n   *\n   * @param options - `SnapshotListenOptions` that control whether metadata-only\n   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n   * snapshot events.\n   */\n  docChanges(\n    options: SnapshotListenOptions = {}\n  ): Array<DocumentChange<AppModelType, DbModelType>> {\n    const includeMetadataChanges = !!options.includeMetadataChanges;\n\n    if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'To include metadata changes with your document changes, you must ' +\n          'also pass { includeMetadataChanges:true } to onSnapshot().'\n      );\n    }\n\n    if (\n      !this._cachedChanges ||\n      this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges\n    ) {\n      this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n      this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n    }\n\n    return this._cachedChanges;\n  }\n\n  static _jsonSchemaVersion: string = 'firestore/querySnapshot/1.0';\n  static _jsonSchema = {\n    type: property('string', QuerySnapshot._jsonSchemaVersion),\n    bundleSource: property('string', 'QuerySnapshot'),\n    bundleName: property('string'),\n    bundle: property('string')\n  };\n\n  /**\n   * Returns a JSON-serializable representation of this `QuerySnapshot` instance.\n   *\n   * @returns a JSON representation of this object. Throws a {@link FirestoreError} if this\n   * `QuerySnapshot` has pending writes.\n   */\n  toJSON(): object {\n    if (this.metadata.hasPendingWrites) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'QuerySnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n          'Await waitForPendingWrites() before invoking toJSON().'\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result: any = {};\n    result['type'] = QuerySnapshot._jsonSchemaVersion;\n    result['bundleSource'] = 'QuerySnapshot';\n    result['bundleName'] = AutoId.newId();\n\n    const databaseId = this._firestore._databaseId.database;\n    const projectId = this._firestore._databaseId.projectId;\n    const parent = `projects/${projectId}/databases/${databaseId}/documents`;\n    const documents: Document[] = [];\n    const documentData: DocumentData[] = [];\n    const paths: string[] = [];\n\n    this.docs.forEach(doc => {\n      if (doc._document === null) {\n        return;\n      }\n      documents.push(doc._document);\n      documentData.push(\n        this._userDataWriter.convertObjectMap(\n          doc._document.data.value.mapValue.fields,\n          'previous'\n        )\n      );\n      paths.push(doc.ref.path);\n    });\n    result['bundle'] = buildQuerySnapshotJsonBundle(\n      this._firestore,\n      this.query._query,\n      result['bundleName'],\n      parent,\n      paths,\n      documents,\n      documentData\n    );\n    return result;\n  }\n}\n\n/**\n * Builds a `QuerySnapshot` instance from a JSON object created by\n * {@link QuerySnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `QuerySnapshot` instance.\n * @returns an instance of {@link QuerySnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function querySnapshotFromJSON(\n  db: Firestore,\n  json: object\n): QuerySnapshot;\n/**\n * Builds a `QuerySnapshot` instance from a JSON object created by\n * {@link QuerySnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `QuerySnapshot` instance.\n * @param converter - Converts objects to and from Firestore.\n * @returns an instance of {@link QuerySnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function querySnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter: FirestoreDataConverter<AppModelType, DbModelType>\n): QuerySnapshot<AppModelType, DbModelType>;\nexport function querySnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter?: FirestoreDataConverter<AppModelType, DbModelType>\n): QuerySnapshot<AppModelType, DbModelType> {\n  if (validateJSON(json, QuerySnapshot._jsonSchema)) {\n    if (json.bundle === NOT_SUPPORTED) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'The provided JSON object was created in a client environment, which is not supported.'\n      );\n    }\n    // Parse the bundle data.\n    const serializer = newSerializer(db._databaseId);\n    const bundleReader = createBundleReaderSync(json.bundle, serializer);\n    const elements = bundleReader.getElements();\n    const bundleLoader: BundleLoader = new BundleLoader(\n      bundleReader.getMetadata(),\n      serializer\n    );\n    for (const element of elements) {\n      bundleLoader.addSizedElement(element);\n    }\n\n    if (bundleLoader.queries.length !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Snapshot data expected 1 query but found ${bundleLoader.queries.length} queries.`\n      );\n    }\n\n    // Create an internal Query object from the named query in the bundle.\n    const query = fromBundledQuery(bundleLoader.queries[0].bundledQuery!);\n\n    // Construct the arrays of document data for the query.\n    const bundledDocuments = bundleLoader.documents;\n    let documentSet = new DocumentSet();\n    bundledDocuments.map(bundledDocument => {\n      const document = fromDocument(serializer, bundledDocument.document!);\n      documentSet = documentSet.add(document);\n    });\n    // Create a view snapshot of the query and documents.\n    const viewSnapshot = ViewSnapshot.fromInitialDocuments(\n      query,\n      documentSet,\n      documentKeySet() /* Zero mutated keys signifies no pending writes. */,\n      /* fromCache= */ false,\n      /* hasCachedResults= */ false\n    );\n\n    // Create an external Query object, required to construct the QuerySnapshot.\n    const externalQuery = new Query<AppModelType, DbModelType>(\n      db,\n      converter ? converter : null,\n      query\n    );\n\n    // Return a new QuerySnapshot with all of the collected data.\n    return new QuerySnapshot<AppModelType, DbModelType>(\n      db,\n      new LiteUserDataWriter(db),\n      externalQuery,\n      viewSnapshot\n    );\n  }\n  throw new FirestoreError(\n    Code.INTERNAL,\n    'Unexpected error creating QuerySnapshot from JSON.'\n  );\n}\n\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nexport function changesFromSnapshot<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  querySnapshot: QuerySnapshot<AppModelType, DbModelType>,\n  includeMetadataChanges: boolean\n): Array<DocumentChange<AppModelType, DbModelType>> {\n  if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    let lastDoc: Document;\n    let index = 0;\n    return querySnapshot._snapshot.docChanges.map(change => {\n      debugAssert(\n        change.type === ChangeType.Added,\n        'Invalid event type for first snapshot'\n      );\n      debugAssert(\n        !lastDoc ||\n          newQueryComparator(querySnapshot._snapshot.query)(\n            lastDoc,\n            change.doc\n          ) < 0,\n        'Got added events in wrong order'\n      );\n      const doc = new QueryDocumentSnapshot<AppModelType, DbModelType>(\n        querySnapshot._firestore,\n        querySnapshot._userDataWriter,\n        change.doc.key,\n        change.doc,\n        new SnapshotMetadata(\n          querySnapshot._snapshot.mutatedKeys.has(change.doc.key),\n          querySnapshot._snapshot.fromCache\n        ),\n        querySnapshot.query.converter\n      );\n      lastDoc = change.doc;\n      return {\n        type: 'added' as DocumentChangeType,\n        doc,\n        oldIndex: -1,\n        newIndex: index++\n      };\n    });\n  } else {\n    // A `DocumentSet` that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    let indexTracker = querySnapshot._snapshot.oldDocs;\n    return querySnapshot._snapshot.docChanges\n      .filter(\n        change => includeMetadataChanges || change.type !== ChangeType.Metadata\n      )\n      .map(change => {\n        const doc = new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          querySnapshot._firestore,\n          querySnapshot._userDataWriter,\n          change.doc.key,\n          change.doc,\n          new SnapshotMetadata(\n            querySnapshot._snapshot.mutatedKeys.has(change.doc.key),\n            querySnapshot._snapshot.fromCache\n          ),\n          querySnapshot.query.converter\n        );\n        let oldIndex = -1;\n        let newIndex = -1;\n        if (change.type !== ChangeType.Added) {\n          oldIndex = indexTracker.indexOf(change.doc.key);\n          debugAssert(oldIndex >= 0, 'Index for document not found');\n          indexTracker = indexTracker.delete(change.doc.key);\n        }\n        if (change.type !== ChangeType.Removed) {\n          indexTracker = indexTracker.add(change.doc);\n          newIndex = indexTracker.indexOf(change.doc.key);\n        }\n        return {\n          type: resultChangeType(change.type),\n          doc,\n          oldIndex,\n          newIndex\n        };\n      });\n  }\n}\n\nexport function resultChangeType(type: ChangeType): DocumentChangeType {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n    case ChangeType.Removed:\n      return 'removed';\n    default:\n      return fail(0xf03d, 'Unknown change type', { type });\n  }\n}\n\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nexport function snapshotEqual<AppModelType, DbModelType extends DocumentData>(\n  left:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>,\n  right:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>\n): boolean {\n  if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      left._key.isEqual(right._key) &&\n      (left._document === null\n        ? right._document === null\n        : left._document.isEqual(right._document)) &&\n      left._converter === right._converter\n    );\n  } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      queryEqual(left.query, right.query) &&\n      left.metadata.isEqual(right.metadata) &&\n      left._snapshot.isEqual(right._snapshot)\n    );\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Return the Platform-specific build JSON bundle implementations. */\nimport { Firestore } from '../../api/database';\nimport { Query } from '../../core/query';\nimport { DocumentData } from '../../lite-api/reference';\nimport { Document } from '../../model/document';\n\nexport function buildDocumentSnapshotJsonBundle(\n  db: Firestore,\n  document: Document,\n  docData: DocumentData,\n  path: string\n): string {\n  return 'NOT SUPPORTED';\n}\n\nexport function buildQuerySnapshotJsonBundle(\n  db: Firestore,\n  query: Query,\n  bundleName: string,\n  parent: string,\n  paths: string[],\n  docs: Document[],\n  documentData: DocumentData[]\n): string {\n  return 'NOT SUPPORTED';\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DEFAULT_TRANSACTION_OPTIONS: TransactionOptions = {\n  maxAttempts: 5\n};\n\n/**\n * Options to customize transaction behavior.\n */\nexport declare interface TransactionOptions {\n  /** Maximum number of attempts to commit, after which transaction fails. Default is 5. */\n  readonly maxAttempts: number;\n}\n\nexport function validateTransactionOptions(options: TransactionOptions): void {\n  if (options.maxAttempts < 1) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Max attempts must be at least 1'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Compat, getModularInstance } from '@firebase/util';\n\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { invokeCommitRpc } from '../remote/datastore';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport { applyFirestoreDataConverter } from './reference_impl';\nimport {\n  newUserDataReader,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UserDataReader\n} from './user_data_reader';\n\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nexport class WriteBatch {\n  // This is the lite version of the WriteBatch API used in the legacy SDK. The\n  // class is a close copy but takes different input types.\n\n  private readonly _dataReader: UserDataReader;\n  private _mutations = [] as Mutation[];\n  private _committed = false;\n\n  /** @hideconstructor */\n  constructor(\n    private readonly _firestore: Firestore,\n    private readonly _commitHandler: (m: Mutation[]) => Promise<void>\n  ) {\n    this._dataReader = newUserDataReader(_firestore);\n  }\n\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType>\n  ): WriteBatch;\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   * If you provide `merge` or `mergeFields`, the provided data can be merged\n   * into an existing document.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @param options - An object to configure the set behavior.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): WriteBatch;\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType> | PartialWithFieldValue<AppModelType>,\n    options?: SetOptions\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n\n    const convertedValue = applyFirestoreDataConverter(\n      ref.converter,\n      data,\n      options\n    );\n    const parsed = parseSetData(\n      this._dataReader,\n      'WriteBatch.set',\n      ref._key,\n      convertedValue,\n      ref.converter !== null,\n      options\n    );\n    this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n    return this;\n  }\n\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param data - An object containing the fields and values with which to\n   * update the document. Fields can contain dots to reference nested fields\n   * within the document.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: UpdateData<DbModelType>\n  ): WriteBatch;\n  /**\n   * Updates fields in the document referred to by this {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * Nested fields can be update by providing dot-separated field path strings\n   * or by providing `FieldPath` objects.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param field - The first field to update.\n   * @param value - The first value.\n   * @param moreFieldsAndValues - Additional key value pairs.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    field: string | FieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch;\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n    let parsed;\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof FieldPath\n    ) {\n      parsed = parseUpdateVarargs(\n        this._dataReader,\n        'WriteBatch.update',\n        ref._key,\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      parsed = parseUpdateData(\n        this._dataReader,\n        'WriteBatch.update',\n        ref._key,\n        fieldOrUpdateData\n      );\n    }\n\n    this._mutations.push(\n      parsed.toMutation(ref._key, Precondition.exists(true))\n    );\n    return this;\n  }\n\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  delete<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n    this._mutations = this._mutations.concat(\n      new DeleteMutation(ref._key, Precondition.none())\n    );\n    return this;\n  }\n\n  /**\n   * Commits all of the writes in this write batch as a single atomic unit.\n   *\n   * The result of these writes will only be reflected in document reads that\n   * occur after the returned promise resolves. If the client is offline, the\n   * write fails. If you would like to see local modifications or buffer writes\n   * until the client is online, use the full Firestore SDK.\n   *\n   * @returns A `Promise` resolved once all of the writes in the batch have been\n   * successfully written to the backend as an atomic unit (note that it won't\n   * resolve while you're offline).\n   */\n  commit(): Promise<void> {\n    this._verifyNotCommitted();\n    this._committed = true;\n    if (this._mutations.length > 0) {\n      return this._commitHandler(this._mutations);\n    }\n\n    return Promise.resolve();\n  }\n\n  private _verifyNotCommitted(): void {\n    if (this._committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'A write batch can no longer be used after commit() ' +\n          'has been called.'\n      );\n    }\n  }\n}\n\nexport function validateReference<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  documentRef:\n    | DocumentReference<AppModelType, DbModelType>\n    | Compat<DocumentReference<AppModelType, DbModelType>>,\n  firestore: Firestore\n): DocumentReference<AppModelType, DbModelType> {\n  documentRef = getModularInstance(documentRef);\n\n  if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Provided document reference is from a different Firestore instance.'\n    );\n  } else {\n    return documentRef as DocumentReference<AppModelType, DbModelType>;\n  }\n}\n\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single WriteBatch\n * is 500.\n *\n * The result of these writes will only be reflected in document reads that\n * occur after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @returns A `WriteBatch` that can be used to atomically execute multiple\n * writes.\n */\nexport function writeBatch(firestore: Firestore): WriteBatch {\n  firestore = cast(firestore, Firestore);\n  const datastore = getDatastore(firestore);\n  return new WriteBatch(firestore, writes =>\n    invokeCommitRpc(datastore, writes)\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport {\n  DEFAULT_TRANSACTION_OPTIONS,\n  TransactionOptions as TransactionOptionsInternal,\n  validateTransactionOptions\n} from '../core/transaction_options';\nimport { TransactionRunner } from '../core/transaction_runner';\nimport { fail } from '../util/assert';\nimport { newAsyncQueue } from '../util/async_queue_impl';\nimport { cast } from '../util/input_validation';\nimport { Deferred } from '../util/promise';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport {\n  applyFirestoreDataConverter,\n  LiteUserDataWriter\n} from './reference_impl';\nimport { DocumentSnapshot } from './snapshot';\nimport { TransactionOptions } from './transaction_options';\nimport {\n  newUserDataReader,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UserDataReader\n} from './user_data_reader';\nimport { validateReference } from './write_batch';\n\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nexport class Transaction {\n  // This is the tree-shakeable version of the Transaction class used in the\n  // legacy SDK. The class is a close copy but takes different input and output\n  // types. The firestore-exp SDK further extends this class to return its API\n  // type.\n\n  private readonly _dataReader: UserDataReader;\n\n  /** @hideconstructor */\n  constructor(\n    protected readonly _firestore: Firestore,\n    private readonly _transaction: InternalTransaction\n  ) {\n    this._dataReader = newUserDataReader(_firestore);\n  }\n\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n    const ref = validateReference(documentRef, this._firestore);\n    const userDataWriter = new LiteUserDataWriter(this._firestore);\n    return this._transaction.lookup([ref._key]).then(docs => {\n      if (!docs || docs.length !== 1) {\n        return fail(0x5de9, 'Mismatch in docs returned from document lookup.');\n      }\n      const doc = docs[0];\n      if (doc.isFoundDocument()) {\n        return new DocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          userDataWriter,\n          doc.key,\n          doc,\n          ref.converter\n        );\n      } else if (doc.isNoDocument()) {\n        return new DocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          userDataWriter,\n          ref._key,\n          null,\n          ref.converter\n        );\n      } else {\n        throw fail(\n          0x4801,\n          'BatchGetDocumentsRequest returned unexpected document',\n          {\n            doc\n          }\n        );\n      }\n    });\n  }\n\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType>\n  ): this;\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   * If you provide `merge` or `mergeFields`, the provided data can be merged\n   * into an existing document.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @param options - An object to configure the set behavior.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): this;\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    value: PartialWithFieldValue<AppModelType>,\n    options?: SetOptions\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n    const convertedValue = applyFirestoreDataConverter(\n      ref.converter,\n      value,\n      options\n    );\n    const parsed = parseSetData(\n      this._dataReader,\n      'Transaction.set',\n      ref._key,\n      convertedValue,\n      ref.converter !== null,\n      options\n    );\n    this._transaction.set(ref._key, parsed);\n    return this;\n  }\n\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param data - An object containing the fields and values with which to\n   * update the document. Fields can contain dots to reference nested fields\n   * within the document.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: UpdateData<DbModelType>\n  ): this;\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * Nested fields can be updated by providing dot-separated field path\n   * strings or by providing `FieldPath` objects.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param field - The first field to update.\n   * @param value - The first value.\n   * @param moreFieldsAndValues - Additional key/value pairs.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    field: string | FieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): this;\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n    let parsed;\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof FieldPath\n    ) {\n      parsed = parseUpdateVarargs(\n        this._dataReader,\n        'Transaction.update',\n        ref._key,\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      parsed = parseUpdateData(\n        this._dataReader,\n        'Transaction.update',\n        ref._key,\n        fieldOrUpdateData\n      );\n    }\n\n    this._transaction.update(ref._key, parsed);\n    return this;\n  }\n\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  delete<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n    this._transaction.delete(ref._key);\n    return this;\n  }\n}\n\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nexport function runTransaction<T>(\n  firestore: Firestore,\n  updateFunction: (transaction: Transaction) => Promise<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  firestore = cast(firestore, Firestore);\n  const datastore = getDatastore(firestore);\n  const optionsWithDefaults: TransactionOptionsInternal = {\n    ...DEFAULT_TRANSACTION_OPTIONS,\n    ...options\n  };\n  validateTransactionOptions(optionsWithDefaults);\n  const deferred = new Deferred<T>();\n  new TransactionRunner<T>(\n    newAsyncQueue(),\n    datastore,\n    optionsWithDefaults,\n    internalTransaction =>\n      updateFunction(new Transaction(firestore, internalTransaction)),\n    deferred\n  ).run();\n  return deferred.promise;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestoreClientTransaction } from '../core/firestore_client';\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport {\n  TransactionOptions as TransactionOptionsInternal,\n  DEFAULT_TRANSACTION_OPTIONS,\n  validateTransactionOptions\n} from '../core/transaction_options';\nimport { DocumentData, DocumentReference } from '../lite-api/reference';\nimport { Transaction as LiteTransaction } from '../lite-api/transaction';\nimport { validateReference } from '../lite-api/write_batch';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { DocumentSnapshot, SnapshotMetadata } from './snapshot';\nimport { TransactionOptions } from './transaction_options';\nimport { ExpUserDataWriter } from './user_data_writer';\n\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nexport class Transaction extends LiteTransaction {\n  // This class implements the same logic as the Transaction API in the Lite SDK\n  // but is subclassed in order to return its own DocumentSnapshot types.\n\n  /** @hideconstructor */\n  constructor(\n    protected readonly _firestore: Firestore,\n    _transaction: InternalTransaction\n  ) {\n    super(_firestore, _transaction);\n  }\n\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n    const ref = validateReference(documentRef, this._firestore);\n    const userDataWriter = new ExpUserDataWriter(this._firestore);\n    return super\n      .get(documentRef)\n      .then(\n        liteDocumentSnapshot =>\n          new DocumentSnapshot(\n            this._firestore,\n            userDataWriter,\n            ref._key,\n            liteDocumentSnapshot._document,\n            new SnapshotMetadata(\n              /* hasPendingWrites= */ false,\n              /* fromCache= */ false\n            ),\n            ref.converter\n          )\n      );\n  }\n}\n\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nexport function runTransaction<T>(\n  firestore: Firestore,\n  updateFunction: (transaction: Transaction) => Promise<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  firestore = cast(firestore, Firestore);\n  const optionsWithDefaults: TransactionOptionsInternal = {\n    ...DEFAULT_TRANSACTION_OPTIONS,\n    ...options\n  };\n  validateTransactionOptions(optionsWithDefaults);\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientTransaction(\n    client,\n    internalTransaction =>\n      updateFunction(new Transaction(firestore, internalTransaction)),\n    optionsWithDefaults\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { loadBundle, namedQuery } from '../api/database';\nimport {\n  CompleteFn,\n  ErrorFn,\n  isPartialObserver,\n  NextFn,\n  PartialObserver\n} from '../api/observer';\nimport { ListenerDataSource } from '../core/event_manager';\nimport {\n  firestoreClientAddSnapshotsInSyncListener,\n  firestoreClientGetDocumentFromLocalCache,\n  firestoreClientGetDocumentsFromLocalCache,\n  firestoreClientGetDocumentsViaSnapshotListener,\n  firestoreClientGetDocumentViaSnapshotListener,\n  firestoreClientListen,\n  firestoreClientWrite\n} from '../core/firestore_client';\nimport { newQueryForPath, Query as InternalQuery } from '../core/query';\nimport { ViewSnapshot } from '../core/view_snapshot';\nimport { FieldPath } from '../lite-api/field_path';\nimport { validateHasExplicitOrderByForLimitToLast } from '../lite-api/query';\nimport {\n  CollectionReference,\n  doc,\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from '../lite-api/reference';\nimport { applyFirestoreDataConverter } from '../lite-api/reference_impl';\nimport {\n  newUserDataReader,\n  ParsedUpdateData,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs\n} from '../lite-api/user_data_reader';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport {\n  DocumentSnapshot,\n  FirestoreDataConverter,\n  QuerySnapshot,\n  SnapshotMetadata\n} from './snapshot';\nimport { ExpUserDataWriter } from './user_data_writer';\n\n/**\n * An options object that can be passed to {@link (onSnapshot:1)} and {@link\n * QuerySnapshot.docChanges} to control which types of changes to include in the\n * result set.\n */\nexport interface SnapshotListenOptions {\n  /**\n   * Include a change even if only the metadata of the query or of a document\n   * changed. Default is false.\n   */\n  readonly includeMetadataChanges?: boolean;\n\n  /**\n   * Set the source the query listens to. Default to \"default\", which\n   * listens to both cache and server.\n   */\n  readonly source?: ListenSource;\n}\n\n/**\n * Describe the source a query listens to.\n *\n * Set to `default` to listen to both cache and server changes. Set to `cache`\n * to listen to changes in cache only.\n */\nexport type ListenSource = 'default' | 'cache';\n\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  return firestoreClientGetDocumentViaSnapshotListener(\n    client,\n    reference._key\n  ).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDocFromCache<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(\n    doc =>\n      new DocumentSnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        reference._key,\n        doc,\n        new SnapshotMetadata(\n          doc !== null && doc.hasLocalMutations,\n          /* fromCache= */ true\n        ),\n        reference.converter\n      )\n  );\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDocFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\n    source: 'server'\n  }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocs<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  validateHasExplicitOrderByForLimitToLast(query._query);\n  return firestoreClientGetDocumentsViaSnapshotListener(\n    client,\n    query._query\n  ).then(\n    snapshot =>\n      new QuerySnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        query,\n        snapshot\n      )\n  );\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocsFromCache<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(\n    snapshot =>\n      new QuerySnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        query,\n        snapshot\n      )\n  );\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocsFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\n    source: 'server'\n  }).then(\n    snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot)\n  );\n}\n\n/**\n * Writes to the document referred to by this `DocumentReference`. If the\n * document does not yet exist, it will be created.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<void>;\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created. If you provide `merge`\n * or `mergeFields`, the provided data can be merged into an existing document.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @param options - An object to configure the set behavior.\n * @returns A Promise resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options: SetOptions\n): Promise<void>;\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options?: SetOptions\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data as WithFieldValue<AppModelType>,\n    options\n  );\n  const dataReader = newUserDataReader(firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'setDoc',\n    reference._key,\n    convertedValue,\n    reference.converter !== null,\n    options\n  );\n\n  const mutation = parsed.toMutation(reference._key, Precondition.none());\n  return executeWrite(firestore, [mutation]);\n}\n\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference`. The update will fail if applied to a document that does\n * not exist.\n *\n * @param reference - A reference to the document to update.\n * @param data - An object containing the fields and values with which to\n * update the document. Fields can contain dots to reference nested fields\n * within the document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: UpdateData<DbModelType>\n): Promise<void>;\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference` The update will fail if applied to a document that does\n * not exist.\n *\n * Nested fields can be updated by providing dot-separated field path\n * strings or by providing `FieldPath` objects.\n *\n * @param reference - A reference to the document to update.\n * @param field - The first field to update.\n * @param value - The first value.\n * @param moreFieldsAndValues - Additional key value pairs.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  field: string | FieldPath,\n  value: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void>;\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<unknown>,\n  fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n  value?: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n\n  const dataReader = newUserDataReader(firestore);\n\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n  let parsed: ParsedUpdateData;\n  if (\n    typeof fieldOrUpdateData === 'string' ||\n    fieldOrUpdateData instanceof FieldPath\n  ) {\n    parsed = parseUpdateVarargs(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData,\n      value,\n      moreFieldsAndValues\n    );\n  } else {\n    parsed = parseUpdateData(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData\n    );\n  }\n\n  const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\n  return executeWrite(firestore, [mutation]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nexport function deleteDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<void> {\n  const firestore = cast(reference.firestore, Firestore);\n  const mutations = [new DeleteMutation(reference._key, Precondition.none())];\n  return executeWrite(firestore, mutations);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nexport function addDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: CollectionReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<DocumentReference<AppModelType, DbModelType>> {\n  const firestore = cast(reference.firestore, Firestore);\n\n  const docRef = doc(reference);\n  const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'addDoc',\n    docRef._key,\n    convertedValue,\n    reference.converter !== null,\n    {}\n  );\n\n  const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\n  return executeWrite(firestore, [mutation]).then(() => docRef);\n}\n\n/**\n * A function returned by `onSnapshot()` that removes the listener when invoked.\n */\nexport interface Unsubscribe {\n  /** Removes the listener when invoked. */\n  (): void;\n}\n\n// TODO(firestorexp): Make sure these overloads are tested via the Firestore\n// integration tests\n\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  observer: {\n    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  observer: {\n    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  observer: {\n    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  observer: {\n    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference:\n    | Query<AppModelType, DbModelType>\n    | DocumentReference<AppModelType, DbModelType>,\n  ...args: unknown[]\n): Unsubscribe {\n  // onSnapshot for Query or Document.\n  reference = getModularInstance(reference);\n  let options: SnapshotListenOptions = {\n    includeMetadataChanges: false,\n    source: 'default'\n  };\n  let currArg = 0;\n  if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n    options = args[currArg++] as SnapshotListenOptions;\n  }\n\n  const internalOptions = {\n    includeMetadataChanges: options.includeMetadataChanges,\n    source: options.source as ListenerDataSource\n  };\n\n  if (isPartialObserver(args[currArg])) {\n    const userObserver = args[currArg] as PartialObserver<\n      QuerySnapshot<AppModelType, DbModelType>\n    >;\n    args[currArg] = userObserver.next?.bind(userObserver);\n    args[currArg + 1] = userObserver.error?.bind(userObserver);\n    args[currArg + 2] = userObserver.complete?.bind(userObserver);\n  }\n\n  let observer: PartialObserver<ViewSnapshot>;\n  let firestore: Firestore;\n  let internalQuery: InternalQuery;\n\n  if (reference instanceof DocumentReference) {\n    firestore = cast(reference.firestore, Firestore);\n    internalQuery = newQueryForPath(reference._key.path);\n\n    observer = {\n      next: snapshot => {\n        if (args[currArg]) {\n          (\n            args[currArg] as NextFn<DocumentSnapshot<AppModelType, DbModelType>>\n          )(\n            convertToDocSnapshot(\n              firestore,\n              reference as DocumentReference<AppModelType, DbModelType>,\n              snapshot\n            )\n          );\n        }\n      },\n      error: args[currArg + 1] as ErrorFn,\n      complete: args[currArg + 2] as CompleteFn\n    };\n  } else {\n    const query = cast<Query<AppModelType, DbModelType>>(reference, Query);\n    firestore = cast(query.firestore, Firestore);\n    internalQuery = query._query;\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    observer = {\n      next: snapshot => {\n        if (args[currArg]) {\n          (args[currArg] as NextFn<QuerySnapshot<AppModelType, DbModelType>>)(\n            new QuerySnapshot(firestore, userDataWriter, query, snapshot)\n          );\n        }\n      },\n      error: args[currArg + 1] as ErrorFn,\n      complete: args[currArg + 2] as CompleteFn\n    };\n\n    validateHasExplicitOrderByForLimitToLast(reference._query);\n  }\n\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientListen(\n    client,\n    internalQuery,\n    internalOptions,\n    observer\n  );\n}\n\n/**\n * Attaches a listener for `QuerySnapshot` events based on data generated by invoking\n * {@link QuerySnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are\n * never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on data generated by invoking\n * {@link QuerySnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks\n * or pass a single observer object with `next` and `error` callbacks. The listener can be cancelled\n * by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on QuerySnapshot data generated by invoking\n * {@link QuerySnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks\n * or pass a single observer object with `next` and `error` callbacks. The listener can be cancelled\n * by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on QuerySnapshot data generated by invoking\n * {@link QuerySnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on QuerySnapshot data generated by\n * invoking {@link DocumentSnapshot.toJSON} You may either pass individual `onNext` and `onError`\n * callbacks or pass a single observer object with `next` and `error` callbacks. The listener can be\n * cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(reference: Firestore, snapshotJson: object, ...args: unknown[]): Unsubscribe {\n  const db = getModularInstance(reference);\n  const json = normalizeSnapshotJsonFields(snapshotJson);\n  if (json.error) {\n    throw new FirestoreError(Code.INVALID_ARGUMENT, json.error);\n  }\n  let curArg = 0;\n  let options: SnapshotListenOptions | undefined = undefined;\n  if (typeof args[curArg] === 'object' && !isPartialObserver(args[curArg])) {\n    options = args[curArg++] as SnapshotListenOptions;\n  }\n\n  if (json.bundleSource === 'QuerySnapshot') {\n    let observer: {\n      next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n      error?: (error: FirestoreError) => void;\n      complete?: () => void;\n    } | null = null;\n    if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n      const userObserver = args[curArg++] as PartialObserver<\n        QuerySnapshot<AppModelType, DbModelType>\n      >;\n      observer = {\n        next: userObserver.next!,\n        error: userObserver.error,\n        complete: userObserver.complete\n      };\n    } else {\n      observer = {\n        next: args[curArg++] as (\n          snapshot: QuerySnapshot<AppModelType, DbModelType>\n        ) => void,\n        error: args[curArg++] as (error: FirestoreError) => void,\n        complete: args[curArg++] as () => void\n      };\n    }\n    return onSnapshotQuerySnapshotBundle(\n      db,\n      json,\n      options,\n      observer!,\n      args[curArg] as FirestoreDataConverter<DbModelType>\n    );\n  } else if (json.bundleSource === 'DocumentSnapshot') {\n    let observer: {\n      next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n      error?: (error: FirestoreError) => void;\n      complete?: () => void;\n    } | null = null;\n    if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n      const userObserver = args[curArg++] as PartialObserver<\n        DocumentSnapshot<AppModelType, DbModelType>\n      >;\n      observer = {\n        next: userObserver.next!,\n        error: userObserver.error,\n        complete: userObserver.complete\n      };\n    } else {\n      observer = {\n        next: args[curArg++] as (\n          snapshot: DocumentSnapshot<AppModelType, DbModelType>\n        ) => void,\n        error: args[curArg++] as (error: FirestoreError) => void,\n        complete: args[curArg++] as () => void\n      };\n    }\n    return onSnapshotDocumentSnapshotBundle(\n      db,\n      json,\n      options,\n      observer!,\n      args[curArg] as FirestoreDataConverter<DbModelType>\n    );\n  } else {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `unsupported bundle source: ${json.bundleSource}`\n    );\n  }\n}\n\n// TODO(firestorexp): Make sure these overloads are tested via the Firestore\n// integration tests\n\n/**\n * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\n * event indicates that all listeners affected by a given change have fired,\n * even if a single server-generated change affects multiple listeners.\n *\n * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\n * with each other, but does not relate to whether those snapshots are in sync\n * with the server. Use SnapshotMetadata in the individual listeners to\n * determine if a snapshot is from the cache or the server.\n *\n * @param firestore - The instance of Firestore for synchronizing snapshots.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n */\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  observer: {\n    next?: (value: void) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\n * event indicates that all listeners affected by a given change have fired,\n * even if a single server-generated change affects multiple listeners.\n *\n * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\n * with each other, but does not relate to whether those snapshots are in sync\n * with the server. Use `SnapshotMetadata` in the individual listeners to\n * determine if a snapshot is from the cache or the server.\n *\n * @param firestore - The `Firestore` instance for synchronizing snapshots.\n * @param onSync - A callback to be called every time all snapshot listeners are\n * in sync with each other.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n */\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  onSync: () => void\n): Unsubscribe;\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  arg: unknown\n): Unsubscribe {\n  firestore = cast(firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const observer = isPartialObserver(arg)\n    ? (arg as PartialObserver<void>)\n    : {\n        next: arg as () => void\n      };\n\n  return firestoreClientAddSnapshotsInSyncListener(client, observer);\n}\n\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nexport function executeWrite(\n  firestore: Firestore,\n  mutations: Mutation[]\n): Promise<void> {\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientWrite(client, mutations);\n}\n\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot<AppModelType, DbModelType extends DocumentData>(\n  firestore: Firestore,\n  ref: DocumentReference<AppModelType, DbModelType>,\n  snapshot: ViewSnapshot\n): DocumentSnapshot<AppModelType, DbModelType> {\n  debugAssert(\n    snapshot.docs.size <= 1,\n    'Expected zero or a single result on a document-only query'\n  );\n  const doc = snapshot.docs.get(ref._key);\n\n  const userDataWriter = new ExpUserDataWriter(firestore);\n  return new DocumentSnapshot<AppModelType, DbModelType>(\n    firestore,\n    userDataWriter,\n    ref._key,\n    doc,\n    new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache),\n    ref.converter\n  );\n}\n\n/**\n * Ensures the data required to construct an {@link onSnapshot} listener exist in a `snapshotJson`\n * object that originates from {@link DocumentSnapshot.toJSON} or {@link Querysnapshot.toJSON}. The\n * data is normalized into a typed object.\n *\n * @param snapshotJson - The JSON object that the app provided to {@link onSnapshot}.\n * @returns A normalized object that contains all of the required bundle JSON fields. If\n * {@link snapshotJson} doesn't contain the required fields, or if the fields exist as empty\n * strings, then the {@link snapshotJson.error} field will be a non empty string.\n *\n * @internal\n */\nfunction normalizeSnapshotJsonFields(snapshotJson: object): {\n  bundle: string;\n  bundleName: string;\n  bundleSource: string;\n  error?: string;\n} {\n  const result: {\n    bundle: string;\n    bundleName: string;\n    bundleSource: string;\n    error?: string;\n  } = {\n    bundle: '',\n    bundleName: '',\n    bundleSource: ''\n  };\n  const requiredKeys = ['bundle', 'bundleName', 'bundleSource'];\n  for (const key of requiredKeys) {\n    if (!(key in snapshotJson)) {\n      result.error = `snapshotJson missing required field: ${key}`;\n      break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const value = (snapshotJson as any)[key];\n    if (typeof value !== 'string') {\n      result.error = `snapshotJson field '${key}' must be a string.`;\n      break;\n    }\n    if (value.length === 0) {\n      result.error = `snapshotJson field '${key}' cannot be an empty string.`;\n      break;\n    }\n    if (key === 'bundle') {\n      result.bundle = value;\n    } else if (key === 'bundleName') {\n      result.bundleName = value;\n    } else if (key === 'bundleSource') {\n      result.bundleSource = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link DocumentReference} for the document in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotDocumentSnapshotBundle<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: { bundle: string; bundleName: string; bundleSource: string },\n  options: SnapshotListenOptions | undefined,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe {\n  let unsubscribed: boolean = false;\n  let internalUnsubscribe: Unsubscribe | undefined;\n  const loadTask = loadBundle(db, json.bundle);\n  loadTask\n    .then(() => {\n      if (!unsubscribed) {\n        const docReference = new DocumentReference(\n          db,\n          converter ? converter : null,\n          DocumentKey.fromPath(json.bundleName)\n        );\n        internalUnsubscribe = onSnapshot(\n          docReference as DocumentReference<AppModelType, DbModelType>,\n          options ? options : {},\n          observer\n        );\n      }\n    })\n    .catch(e => {\n      if (observer.error) {\n        observer.error(e);\n      }\n      return () => {};\n    });\n  return () => {\n    if (unsubscribed) {\n      return;\n    }\n    unsubscribed = true;\n    if (internalUnsubscribe) {\n      internalUnsubscribe();\n    }\n  };\n}\n\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link Query} that represents the Query in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotQuerySnapshotBundle<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: { bundle: string; bundleName: string; bundleSource: string },\n  options: SnapshotListenOptions | undefined,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe {\n  let unsubscribed: boolean = false;\n  let internalUnsubscribe: Unsubscribe | undefined;\n  const loadTask = loadBundle(db, json.bundle);\n  loadTask\n    .then(() => namedQuery(db, json.bundleName))\n    .then(query => {\n      if (query && !unsubscribed) {\n        const realQuery: Query = (query as Query)!;\n        if (converter) {\n          realQuery.withConverter(converter);\n        }\n        internalUnsubscribe = onSnapshot(\n          query as Query<AppModelType, DbModelType>,\n          options ? options : {},\n          observer\n        );\n      }\n    })\n    .catch(e => {\n      if (observer.error) {\n        observer.error(e);\n      }\n      return () => {};\n    });\n  return () => {\n    if (unsubscribed) {\n      return;\n    }\n    unsubscribed = true;\n    if (internalUnsubscribe) {\n      internalUnsubscribe();\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WriteBatch } from '../lite-api/write_batch';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { executeWrite } from './reference_impl';\n\nexport { WriteBatch };\n\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nexport function writeBatch(firestore: Firestore): WriteBatch {\n  firestore = cast(firestore, Firestore);\n  ensureFirestoreConfigured(firestore);\n  return new WriteBatch(firestore, mutations =>\n    executeWrite(firestore, mutations)\n  );\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestoreClientSetIndexConfiguration } from '../core/firestore_client';\nimport { fieldPathFromDotSeparatedString } from '../lite-api/user_data_reader';\nimport {\n  FieldIndex,\n  IndexKind,\n  IndexSegment,\n  IndexState\n} from '../model/field_index';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\nimport { logWarn } from '../util/log';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\n\nexport {\n  connectFirestoreEmulator,\n  EmulatorMockTokenOptions\n} from '../lite-api/database';\n\n/**\n * A single field element in an index configuration.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface IndexField {\n  /** The field path to index. */\n  readonly fieldPath: string;\n  /**\n   * What type of array index to create. Set to `CONTAINS` for `array-contains`\n   * and `array-contains-any` indexes.\n   *\n   * Only one of `arrayConfig` or `order` should be set;\n   */\n  readonly arrayConfig?: 'CONTAINS';\n  /**\n   * What type of array index to create. Set to `ASCENDING` or 'DESCENDING` for\n   * `==`, `!=`, `<=`, `<=`, `in` and `not-in` filters.\n   *\n   * Only one of `arrayConfig` or `order` should be set.\n   */\n  readonly order?: 'ASCENDING' | 'DESCENDING';\n\n  [key: string]: unknown;\n}\n\n/**\n * The SDK definition of a Firestore index.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface Index {\n  /** The ID of the collection to index. */\n  readonly collectionGroup: string;\n  /** A list of fields to index. */\n  readonly fields?: IndexField[];\n\n  [key: string]: unknown;\n}\n\n/**\n * A list of Firestore indexes to speed up local query execution.\n *\n * See {@link https://firebase.google.com/docs/reference/firestore/indexes/#json_format | JSON Format}\n * for a description of the format of the index definition.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface IndexConfiguration {\n  /** A list of all Firestore indexes. */\n  readonly indexes?: Index[];\n\n  [key: string]: unknown;\n}\n\n/**\n * Configures indexing for local query execution. Any previous index\n * configuration is overridden. The `Promise` resolves once the index\n * configuration has been persisted.\n *\n * The index entries themselves are created asynchronously. You can continue to\n * use queries that require indexing even if the indices are not yet available.\n * Query execution will automatically start using the index once the index\n * entries have been written.\n *\n * Indexes are only supported with IndexedDb persistence. If IndexedDb is not\n * enabled, any index configuration is ignored.\n *\n * @param firestore - The {@link Firestore} instance to configure indexes for.\n * @param configuration -The index definition.\n * @throws FirestoreError if the JSON format is invalid.\n * @returns A `Promise` that resolves once all indices are successfully\n * configured.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  configuration: IndexConfiguration\n): Promise<void>;\n\n/**\n * Configures indexing for local query execution. Any previous index\n * configuration is overridden. The `Promise` resolves once the index\n * configuration has been persisted.\n *\n * The index entries themselves are created asynchronously. You can continue to\n * use queries that require indexing even if the indices are not yet available.\n * Query execution will automatically start using the index once the index\n * entries have been written.\n *\n * Indexes are only supported with IndexedDb persistence. Invoke either\n * `enableIndexedDbPersistence()` or `enableMultiTabIndexedDbPersistence()`\n * before setting an index configuration. If IndexedDb is not enabled, any\n * index configuration is ignored.\n *\n * The method accepts the JSON format exported by the Firebase CLI (`firebase\n * firestore:indexes`). If the JSON format is invalid, this method throws an\n * error.\n *\n * @param firestore - The {@link Firestore} instance to configure indexes for.\n * @param json -The JSON format exported by the Firebase CLI.\n * @throws FirestoreError if the JSON format is invalid.\n * @returns A `Promise` that resolves once all indices are successfully\n * configured.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  json: string\n): Promise<void>;\n\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  jsonOrConfiguration: string | IndexConfiguration\n): Promise<void> {\n  firestore = cast(firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  if (\n    !client._uninitializedComponentsProvider ||\n    client._uninitializedComponentsProvider._offline.kind === 'memory'\n  ) {\n    // PORTING NOTE: We don't return an error if the user has not enabled\n    // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n    logWarn('Cannot enable indexes when persistence is disabled');\n    return Promise.resolve();\n  }\n  const parsedIndexes = parseIndexes(jsonOrConfiguration);\n  return firestoreClientSetIndexConfiguration(client, parsedIndexes);\n}\n\nexport function parseIndexes(\n  jsonOrConfiguration: string | IndexConfiguration\n): FieldIndex[] {\n  const indexConfiguration =\n    typeof jsonOrConfiguration === 'string'\n      ? (tryParseJson(jsonOrConfiguration) as IndexConfiguration)\n      : jsonOrConfiguration;\n  const parsedIndexes: FieldIndex[] = [];\n\n  if (Array.isArray(indexConfiguration.indexes)) {\n    for (const index of indexConfiguration.indexes) {\n      const collectionGroup = tryGetString(index, 'collectionGroup');\n\n      const segments: IndexSegment[] = [];\n      if (Array.isArray(index.fields)) {\n        for (const field of index.fields) {\n          const fieldPathString = tryGetString(field, 'fieldPath');\n          const fieldPath = fieldPathFromDotSeparatedString(\n            'setIndexConfiguration',\n            fieldPathString\n          );\n\n          if (field.arrayConfig === 'CONTAINS') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.CONTAINS));\n          } else if (field.order === 'ASCENDING') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.ASCENDING));\n          } else if (field.order === 'DESCENDING') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.DESCENDING));\n          }\n        }\n      }\n\n      parsedIndexes.push(\n        new FieldIndex(\n          FieldIndex.UNKNOWN_ID,\n          collectionGroup,\n          segments,\n          IndexState.empty()\n        )\n      );\n    }\n  }\n  return parsedIndexes;\n}\n\nfunction tryParseJson(json: string): Record<string, unknown> {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Failed to parse JSON: ' + (e as Error)?.message\n    );\n  }\n}\n\nfunction tryGetString(data: Record<string, unknown>, property: string): string {\n  if (typeof data[property] !== 'string') {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Missing string value for: ' + property\n    );\n  }\n  return data[property] as string;\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  firestoreClientDeleteAllFieldIndexes,\n  firestoreClientSetPersistentCacheIndexAutoCreationEnabled\n} from '../core/firestore_client';\nimport { cast } from '../util/input_validation';\nimport { logDebug, logWarn } from '../util/log';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\n\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nexport class PersistentCacheIndexManager {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type: 'PersistentCacheIndexManager' = 'PersistentCacheIndexManager';\n\n  /** @hideconstructor */\n  constructor(readonly _firestore: Firestore) {}\n}\n\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @returns The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nexport function getPersistentCacheIndexManager(\n  firestore: Firestore\n): PersistentCacheIndexManager | null {\n  firestore = cast(firestore, Firestore);\n\n  const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n  if (cachedInstance) {\n    return cachedInstance;\n  }\n\n  const client = ensureFirestoreConfigured(firestore);\n  if (client._uninitializedComponentsProvider?._offline.kind !== 'persistent') {\n    return null;\n  }\n\n  const instance = new PersistentCacheIndexManager(firestore);\n  persistentCacheIndexManagerByFirestore.set(firestore, instance);\n  return instance;\n}\n\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nexport function enablePersistentCacheIndexAutoCreation(\n  indexManager: PersistentCacheIndexManager\n): void {\n  setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nexport function disablePersistentCacheIndexAutoCreation(\n  indexManager: PersistentCacheIndexManager\n): void {\n  setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nexport function deleteAllPersistentCacheIndexes(\n  indexManager: PersistentCacheIndexManager\n): void {\n  const client = ensureFirestoreConfigured(indexManager._firestore);\n  const promise = firestoreClientDeleteAllFieldIndexes(client);\n\n  promise\n    .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\n    .catch(error =>\n      logWarn('deleting all persistent cache indexes failed', error)\n    );\n}\n\nfunction setPersistentCacheIndexAutoCreationEnabled(\n  indexManager: PersistentCacheIndexManager,\n  isEnabled: boolean\n): void {\n  const client = ensureFirestoreConfigured(indexManager._firestore);\n  const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(\n    client,\n    isEnabled\n  );\n\n  promise\n    .then(_ =>\n      logDebug(\n        `setting persistent cache index auto creation ` +\n          `isEnabled=${isEnabled} succeeded`\n      )\n    )\n    .catch(error =>\n      logWarn(\n        `setting persistent cache index auto creation ` +\n          `isEnabled=${isEnabled} failed`,\n        error\n      )\n    );\n}\n\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap<\n  Firestore,\n  PersistentCacheIndexManager\n>();\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Unsubscribe } from '../api/reference_impl';\n\nimport {\n  setTestingHooksSpi,\n  ExistenceFilterMismatchInfo,\n  TestingHooksSpi\n} from './testing_hooks_spi';\n\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nexport class TestingHooks {\n  private constructor() {\n    throw new Error('instances of this class should not be created');\n  }\n\n  /**\n   * Registers a callback to be notified when an existence filter mismatch\n   * occurs in the Watch listen stream.\n   *\n   * The relative order in which callbacks are notified is unspecified; do not\n   * rely on any particular ordering. If a given callback is registered multiple\n   * times then it will be notified multiple times, once per registration.\n   *\n   * @param callback - the callback to invoke upon existence filter mismatch.\n   *\n   * @returns a function that, when called, unregisters the given callback; only\n   * the first invocation of the returned function does anything; all subsequent\n   * invocations do nothing.\n   */\n  static onExistenceFilterMismatch(\n    callback: ExistenceFilterMismatchCallback\n  ): Unsubscribe {\n    return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n  }\n}\n\n/**\n * The signature of callbacks registered with\n * `TestingUtils.onExistenceFilterMismatch()`.\n *\n * The return value, if any, is ignored.\n *\n * @internal\n */\nexport type ExistenceFilterMismatchCallback = (\n  info: ExistenceFilterMismatchInfo\n) => unknown;\n\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl implements TestingHooksSpi {\n  private readonly existenceFilterMismatchCallbacksById = new Map<\n    Symbol,\n    ExistenceFilterMismatchCallback\n  >();\n\n  private constructor() {}\n\n  static get instance(): TestingHooksSpiImpl {\n    if (!testingHooksSpiImplInstance) {\n      testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n      setTestingHooksSpi(testingHooksSpiImplInstance);\n    }\n    return testingHooksSpiImplInstance;\n  }\n\n  notifyOnExistenceFilterMismatch(info: ExistenceFilterMismatchInfo): void {\n    this.existenceFilterMismatchCallbacksById.forEach(callback =>\n      callback(info)\n    );\n  }\n\n  onExistenceFilterMismatch(\n    callback: ExistenceFilterMismatchCallback\n  ): Unsubscribe {\n    const id = Symbol();\n    const callbacks = this.existenceFilterMismatchCallbacksById;\n    callbacks.set(id, callback);\n    return () => callbacks.delete(id);\n  }\n}\n\nlet testingHooksSpiImplInstance: TestingHooksSpiImpl | null = null;\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  _registerComponent,\n  registerVersion,\n  SDK_VERSION\n} from '@firebase/app';\nimport { Component, ComponentType } from '@firebase/component';\n\nimport { name, version } from '../package.json';\nimport {\n  FirebaseAppCheckTokenProvider,\n  FirebaseAuthCredentialsProvider\n} from '../src/api/credentials';\nimport { setSDKVersion } from '../src/core/version';\n\nimport { Firestore } from './api/database';\nimport { databaseIdFromApp } from './core/database_info';\n\nexport function registerFirestore(\n  variant?: string,\n  useFetchStreams = true\n): void {\n  setSDKVersion(SDK_VERSION);\n  _registerComponent(\n    new Component(\n      'firestore',\n      (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate()!;\n        const firestoreInstance = new Firestore(\n          new FirebaseAuthCredentialsProvider(\n            container.getProvider('auth-internal')\n          ),\n          new FirebaseAppCheckTokenProvider(\n            app,\n            container.getProvider('app-check-internal')\n          ),\n          databaseIdFromApp(app, databaseId),\n          app\n        );\n        settings = { useFetchStreams, ...settings };\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n      },\n      'PUBLIC' as ComponentType.PUBLIC\n    ).setMultipleInstances(true)\n  );\n  registerVersion(name, version, variant);\n  // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation\n  registerVersion(name, version, '__BUILD_TARGET__');\n}\n","/**\n * Cloud Firestore\n *\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from './api/database';\nimport { registerFirestore } from './register';\n\nregisterFirestore();\n\nexport * from './api';\n\ndeclare module '@firebase/component' {\n  interface NameServiceMapping {\n    'firestore': Firestore;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}